<head>
<title>YAF - Documentation - yafscii</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

        <link rel="stylesheet" type="text/css" href="../site/style.css" />

</head>
<body>
    <div id="p-body">
      <div id="l-header">
        <img src="../site/sei-logo.png" id="l-sei-logo"
            alt="Software Engineering Institute | Carnegie Mellon&copy;" />
        <div id="l-netsa-logo"><a id="l-netsa-name" href="../index.html"><b>CERT NetSA Security Suite</b></a></div>
        <div id="l-netsa-motto">Monitoring for Large-Scale Networks</div>
        <h1 class="l-page-title">YAF</h1>
        <span id="l-subtitle">Documentation</span>
      </div><!-- l-header -->
      <div id="l-content">
        <div id="l-sidebar">
          <div class="p-sidebar-section">
            <h1><a href="index.html">YAF</a></h1>
            <ul>
              <li><a href="docs.html">Documentation</a></li>
              <li><a href="download.html">Downloads</a></li>
            </ul>
          </div><!-- p-sidebar-section -->
        </div><!-- l-sidebar -->
<p>
</p>

<h1><a name="name">NAME</a></h1>
<p><strong>yafscii</strong> - YAF Flow Printer</p>
<p>
</p>

<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    yafscii [--in INPUT_SPECIFIER] [--out OUTPUT_SPECIFIER]
            [--nextdir PROCESSED_INPUT_DIRECTORY]
            [--faildir FAILED_INPUT_DIRECTORY]
            [--poll POLLING_DELAY] [--lock]
            [--log LOG_SPECIFIER] [--loglevel LOG_LEVEL]
            [--verbose] [--version] [--daemon] [--foreground]
            [--tabular] [--mac] [--print-header]</pre>
<p>
</p>

<h1><a name="description">DESCRIPTION</a></h1>
<p><strong>yafscii</strong> takes IPFIX flow data files generated by <code>yaf(1)</code> and prints them 
in an ASCII format loosely analogous to that produced by <code>tcpdump(1)</code>, with one 
flow per line. The text output format is detailed in the <strong>OUTPUT</strong> section, 
below. <strong>yafscii</strong> is generally intended to be used to print single files for 
verification or debugging purposes, or to operate in a pipe with <code>yaf(1)</code>,
but it can be used as a daemon as well.  <strong>yafscii</strong> ignores <code>yaf(1)</code> stats records.</p>
<p>
</p>

<h1><a name="options">OPTIONS</a></h1>
<p>
</p>
<h2><a name="input_options">Input Options</a></h2>
<p>The input specifier determines where yafscii will read its 
input from. If the input specifier is not given, yaf defaults to reading 
from standard input.</p>
<dl>
<dt><strong><a name="in_input_specifier" class="item"><strong>--in</strong> <em>INPUT_SPECIFIER</em></a></strong></dt>

<dd>
<p><em>INPUT_SPECIFIER</em> is an input specifier. This is a filename, a directory 
name, a file glob pattern (in which case it should be 
escaped or quoted to prevent the shell from expanding the glob pattern), or 
the string <strong>-</strong> to read from standard input.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="output_options">Output Options</a></h2>
<p>The output specifier determines where yaf will send its output. If reading 
standard input, output defaults to standard output. If reading from files on 
disk, output defaults to one file per input file, named as the input file in 
the same directory as the input file with a <strong>.txt</strong> extension.</p>
<dl>
<dt><strong><a name="out_output_specifier" class="item"><strong>--out</strong> <em>OUTPUT_SPECIFIER</em></a></strong></dt>

<dd>
<p><em>OUTPUT_SPECIFIER</em> is an output specifier. This should be a filename or a 
directory name, or the string <strong>-</strong> to write to standard output.</p>
</dd>
<dt><strong><a name="tabular" class="item"><strong>--tabular</strong></a></strong></dt>

<dd>
<p>Use tabular output mode, which is designed for easy parsability over
human readability. See the Tabular Output section below for details.</p>
</dd>
<dt><strong><a name="mac" class="item"><strong>--mac</strong></a></strong></dt>

<dd>
<p>Used with <strong>--tabular</strong> mode to print source and destination MAC Addresses.</p>
</dd>
<dt><strong><a name="print_header" class="item"><strong>--print-header</strong></a></strong></dt>

<dd>
<p>Used with <strong>--tabular</strong> mode to print column headers.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="daemon_options">Daemon Options</a></h2>
<p>These options are used to run yafscii in daemon mode for batch processing of
pcap dumpfiles.</p>
<dl>
<dt><strong><a name="daemon" class="item"><strong>--daemon</strong></a></strong></dt>

<dd>
<p>Run yafscii in daemon mode. Instead of processing its input then exiting, 
yafscii will continually look for new input matching its input specifier. 
This will cause yaf to fork into the background and exit.
=item <strong>--foreground</strong></p>
<p>Instead of forking in <strong>--daemon</strong> mode, stay in the foreground. 
Useful for debugging.</p>
</dd>
<dt><strong><a name="lock" class="item"><strong>--lock</strong></a></strong></dt>

<dd>
<p>Use lockfiles for concurrent file access protection. Highly recommended in 
<strong>--daemon</strong> mode, especially if two daemons are interacting through a 
given directory.</p>
</dd>
<dt><strong><a name="poll_polling_delay" class="item"><strong>--poll</strong> <em>POLLING_DELAY</em></a></strong></dt>

<dd>
<p><em>POLLING_DELAY</em> is the polling delay in seconds; how long yaf will 
wait for new input when none is available. The default is 60 seconds.</p>
</dd>
<dt><strong><a name="nextdir_processed_input_directory" class="item"><strong>--nextdir</strong> <em>PROCESSED_INPUT_DIRECTORY</em></a></strong></dt>

<dd>
<p>When reading from files, if this option is present, input files will be 
moved to <em>PROCESSED_INPUT_DIRECTORY</em> after they are successfully processed. 
The special string <strong>delete</strong> will cause successfully processed input to be 
removed instead. This option is required in daemon mode.</p>
</dd>
<dt><strong><a name="faildir_failed_input_directory" class="item"><strong>--faildir</strong> <em>FAILED_INPUT_DIRECTORY</em></a></strong></dt>

<dd>
<p>When reading from files, if this option is present, input files will be 
moved to <em>FAILED_INPUT_DIRECTORY</em> if processing failed. 
The special string <strong>delete</strong> will cause failed input to be 
removed instead. This option is required in daemon mode.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="logging_options">Logging Options</a></h2>
<p>These options are used to specify how log messages are routed. yaf can 
log to standard error, regular files, or the UNIX syslog facility.</p>
<dl>
<dt><strong><a name="log_log_specifier" class="item"><strong>--log</strong> <em>LOG_SPECIFIER</em></a></strong></dt>

<dd>
<p>Specifies destination for log messages. <em>LOG_SPECIFIER</em> can be a <code>syslog(3)</code>
facility name, the special value <strong>stderr</strong> for standard error, or the 
<em>absolute</em> path to a file for file logging. Standard error logging is only 
available in <strong>--daemon</strong> mode if <strong>--foreground</strong> is present. The default log 
specifier is <strong>stderr</strong> if available, <strong>user</strong> otherwise.</p>
</dd>
<dt><strong><a name="loglevel_log_level" class="item"><strong>--loglevel</strong> <em>LOG_LEVEL</em></a></strong></dt>

<dd>
<p>Specify minimum level for logged messages. In increasing levels of verbosity, 
the supported log levels are <strong>quiet</strong>, <strong>error</strong>, <strong>critical</strong>, <strong>warning</strong>, 
<strong>message</strong>, <strong>info</strong>, and <strong>debug</strong>. The default logging level is <strong>warning</strong>.</p>
</dd>
<dt><strong><a name="verbose" class="item"><strong>--verbose</strong></a></strong></dt>

<dd>
<p>Equivalent to <strong>--loglevel debug</strong>.</p>
</dd>
<dt><strong><a name="version" class="item"><strong>--version</strong></a></strong></dt>

<dd>
<p>If present, print version and copyright information to standard error and exit.</p>
</dd>
</dl>
<p>
</p>

<h1><a name="output">OUTPUT</a></h1>
<p>
</p>
<h2><a name="human_readable_output">Human-Readable Output</a></h2>
<p>yafscii's default output format, like that of tcpdump, is designed to be easily 
human-readable, at the possible expense of ease of automated parsing. 
Each flow is represented by a single output line representing the flow 
itself, followed by zero or more indented lines containing flow payload in 
hexdump format. This section details each flow format, where each field 
specifier is as follows:</p>
<dl>
<dt><strong><a name="start_time_end_time" class="item"><em>start-time</em>, <em>end-time</em></a></strong></dt>

<dd>
<p>Flow start or end time in ISO 8601 format, with milliseconds 
(<em>YYYY</em>-<em>MM</em>-<em>DD</em> <em>hh</em>:<em>mm</em>:<em>ss</em>.<em>ssss</em>). Start time is printed with
a date; end time is not. End time is only present if the flow has a
non-zero duration.</p>
</dd>
<dt><strong><a name="duration" class="item"><em>duration</em></a></strong></dt>

<dd>
<p>Flow duration in fractional seconds. Only present if the flow has a 
non-zero duration.</p>
</dd>
<dt><strong><a name="proto" class="item"><em>proto</em></a></strong></dt>

<dd>
<p>IP protocol identifier in decimal format.</p>
</dd>
<dt><strong><a name="sip_dip" class="item"><em>sip</em>, <em>dip</em></a></strong></dt>

<dd>
<p>Source or destination IPv4 address in dotted-quad format or IPv6 address in 
<a href="http://www.ietf.org/rfc/rfc2373.txt" class="rfc">RFC 2373</a> format.</p>
</dd>
<dt><strong><a name="sp_dp" class="item"><em>sp</em>, <em>dp</em></a></strong></dt>

<dd>
<p>Source or destination transport port in decimal format.</p>
</dd>
<dt><strong><a name="type_code" class="item"><em>type</em>, <em>code</em></a></strong></dt>

<dd>
<p>ICMP type or code in decimal format.</p>
</dd>
<dt><strong><a name="isn_risn" class="item"><em>isn</em>, <em>risn</em></a></strong></dt>

<dd>
<p>Forward or reverse initial TCP sequence number in hexadecimal format.</p>
</dd>
<dt><strong><a name="iflags_riflags_uflags_ruflags" class="item"><em>iflags</em>, <em>riflags</em>, <em>uflags</em>, <em>ruflags</em></a></strong></dt>

<dd>
<p>Foward or reverse first-packet TCP flags; forward or reverse <em>n</em>th-packet 
TCP flags union; where each flags bit is represented by the first character 
in the flag's name: <strong>F</strong>IN, <strong>S</strong>YN, <strong>R</strong>ST, <strong>P</strong>SH, <strong>A</strong>CK, <strong>U</strong>RG, <strong>E</strong>CE, 
<strong>C</strong>WR. The character <strong>0</strong> means no flags are set (and will appear in the 
<em>n</em>th-packet field for single-packet TCP flows).</p>
</dd>
<dt><strong><a name="tag_rtag" class="item"><em>tag</em>, <em>rtag</em></a></strong></dt>

<dd>
<p>Forward or reverse first-packet 802.1q VLAN tag in hexadecimal format.</p>
</dd>
<dt><strong><a name="srcmacaddress_destmacaddress" class="item"><em>srcMacAddress</em>, <em>destMacAddress</em></a></strong></dt>

<dd>
<p>Source or Destination MAC Address.</p>
</dd>
<dt><strong><a name="pkt_rpkt" class="item"><em>pkt</em>, <em>rpkt</em></a></strong></dt>

<dd>
<p>Forward or reverse packet count in decimal format.</p>
</dd>
<dt><strong><a name="oct_roct" class="item"><em>oct</em>, <em>roct</em></a></strong></dt>

<dd>
<p>Forward or reverse octet count in decimal format.</p>
</dd>
<dt><strong><a name="rtt" class="item"><em>rtt</em></a></strong></dt>

<dd>
<p>Round-trip time estimate in milliseconds in decimal format.</p>
</dd>
<dt><strong><a name="end_reason" class="item"><em>end-reason</em></a></strong></dt>

<dd>
<p>If not present, the flow ended normally (i.e., by TCP RST or FIN). Otherwise, the <em>end-reason</em> is one of the following strings:</p>
<dl>
<dt><strong><a name="idle" class="item"><strong>idle</strong></a></strong></dt>

<dd>
<p>Flow was expired by idle timeout. No packets were received for 
<em>IDLE_TIMEOUT</em> seconds (see yaf(1)) and the flow was presumed closed.</p>
</dd>
<dt><strong><a name="active" class="item"><strong>active</strong></a></strong></dt>

<dd>
<p>Flow was expired by active timeout. The flow's duration was longer than 
<em>ACTIVE_TIMEOUT</em> seconds (see yaf(1)) and the flow was flushed from the 
flow table.</p>
</dd>
<dt><strong><a name="eof" class="item"><strong>eof</strong></a></strong></dt>

<dd>
<p>Flow was still active in the flow table at the end of the dumpfile or at 
<code>yaf(1)</code> shutdown time; it was flushed as the flow table was cleared.</p>
</dd>
<dt><strong><a name="rsrc" class="item"><strong>rsrc</strong></a></strong></dt>

<dd>
<p>Flow was prematurely flushed as <strong>idle</strong> because more than <em>FLOW_TABLE_MAX</em> 
flows (see yaf(1)) were active in the flow table.</p>
</dd>
<dt><strong><a name="force" class="item"><strong>force</strong></a></strong></dt>

<dd>
<p><strong>yaf</strong> forced a write of the flow, but the flow remained open.  This is only seen if yaf operated with the <strong>--udp-uniflow</strong> flag, which exports each UDP packet as a flow record, but allows the flow to remain open until it closes naturally by idle and active timeouts (see yaf(1)).</p>
</dd>
</dl>
</dd>
<dt><strong><a name="applabel" class="item"><strong>applabel</strong></a></strong></dt>

<dd>
<p>The application label, if <code>yaf(1)</code> was built with application labeling enabled and
the application labeler was able to identify the payload in the flow.</p>
</dd>
<dt><strong><a name="entropy" class="item"><strong>entropy</strong></a></strong></dt>

<dd>
<p>The Shannon-Fano Entropy for the forward then the reverse flow payload if the payload
existed and <code>yaf(1)</code> was built with entropy enabled.</p>
</dd>
</dl>
<p>Each flow line format is as follows:</p>
<dl>
<dt><strong><a name="unidirectional_ip_flow" class="item">Unidirectional IP flow</a></strong></dt>

<dd>
<p><em>start-time</em> [<strong>-</strong> <em>end-time</em> <strong>(</strong><em>duration</em> <strong>sec)</strong>] <strong>ip</strong> <em>proto</em> <em>sip</em> <strong>=&gt;</strong> <em>dip</em> [<strong>vlan</strong> <em>tag</em>] <strong>(</strong><em>pkt</em><strong>&sol;</strong><em>oct</em> <strong>-&gt;)</strong> [<em>end-reason</em>]</p>
</dd>
<dt><strong><a name="unidirectional_udp_flow" class="item">Unidirectional UDP flow</a></strong></dt>

<dd>
<p><em>start-time</em> [<strong>-</strong> <em>end-time</em> <strong>(</strong><em>duration</em> <strong>sec)</strong>] <strong>udp</strong> <em>sip</em><strong>:</strong><em>sp</em> <strong>=&gt;</strong> <em>dip</em><strong>:</strong><em>dp</em> [<strong>vlan</strong> <em>tag</em>] <strong>(</strong><em>pkt</em><strong>&sol;</strong><em>oct</em> <strong>-&gt;)</strong> [<em>end-reason</em>]</p>
</dd>
<dt><strong><a name="unidirectional_tcp_flow" class="item">Unidirectional TCP flow</a></strong></dt>

<dd>
<p><em>start-time</em> [<strong>-</strong> <em>end-time</em> <strong>(</strong><em>duration</em> <strong>sec)</strong>] <strong>tcp</strong> <em>sip</em><strong>:</strong><em>sp</em> <strong>=&gt;</strong> <em>dip</em><strong>:</strong><em>dp</em> <em>isn</em> <em>iflags</em><strong>&sol;</strong><em>uflags</em> [<strong>vlan</strong> <em>tag</em>] <strong>(</strong><em>pkt</em><strong>&sol;</strong><em>oct</em> <strong>-&gt;)</strong> [<em>end-reason</em>]</p>
</dd>
<dt><strong><a name="unidirectional_icmp_flow" class="item">Unidirectional ICMP flow</a></strong></dt>

<dd>
<p><em>start-time</em> [<strong>-</strong> <em>end-time</em> <strong>(</strong><em>duration</em> <strong>sec)</strong>] <strong>icmp</strong> <strong>[</strong><em>type</em><strong>:</strong><em>code</em><strong>]</strong> <em>sip</em> <strong>=&gt;</strong> <em>dip</em> [<strong>vlan</strong> <em>tag</em>] <strong>(</strong><em>pkt</em><strong>&sol;</strong><em>oct</em> <strong>-&gt;)</strong> [<em>end-reason</em>]</p>
</dd>
<dt><strong><a name="bidirectional_ip_flow" class="item">Bidirectional IP flow</a></strong></dt>

<dd>
<p><em>start-time</em> [<strong>-</strong> <em>end-time</em> <strong>(</strong><em>duration</em> <strong>sec)</strong>] <strong>ip</strong> <em>proto</em> <em>sip</em> <strong>=&gt;</strong> <em>dip</em> [<strong>vlan</strong> <em>tag</em><strong>:</strong><em>rtag</em>] <strong>(</strong><em>pkt</em><strong>&sol;</strong><em>oct</em> <strong>&lt;-&gt;</strong> <em>rpkt</em><strong>&sol;</strong><em>roct</em><strong>) rtt</strong> <em>rtt</em> <strong>ms</strong> [<em>end-reason</em>]</p>
</dd>
<dt><strong><a name="bidirectional_udp_flow" class="item">Bidirectional UDP flow</a></strong></dt>

<dd>
<p><em>start-time</em> [<strong>-</strong> <em>end-time</em> <strong>(</strong><em>duration</em> <strong>sec)</strong>] <strong>udp</strong> <em>sip</em><strong>:</strong><em>sp</em> <strong>=&gt;</strong> <em>dip</em><strong>:</strong><em>dp</em> [<strong>vlan</strong> <em>tag</em><strong>:</strong><em>rtag</em>] <strong>(</strong><em>pkt</em><strong>&sol;</strong><em>oct</em> <strong>&lt;-&gt;</strong> <em>rpkt</em><strong>&sol;</strong><em>roct</em><strong>) rtt</strong> <em>rtt</em> <strong>ms</strong> [<em>end-reason</em>]</p>
</dd>
<dt><strong><a name="bidirectional_tcp_flow" class="item">Bidirectional TCP flow</a></strong></dt>

<dd>
<p><em>start-time</em> [<strong>-</strong> <em>end-time</em> <strong>(</strong><em>duration</em> <strong>sec)</strong>] <strong>tcp</strong> <em>sip</em><strong>:</strong><em>sp</em> <strong>=&gt;</strong> <em>dip</em><strong>:</strong><em>dp</em> <em>isn</em><strong>:</strong><em>risn</em> <em>iflags</em><strong>&sol;</strong><em>uflags</em><strong>:</strong><em>riflags</em><strong>&sol;</strong><em>ruflags</em> [<strong>vlan</strong> <em>tag</em><strong>:</strong><em>rtag</em>] <strong>(</strong><em>pkt</em><strong>&sol;</strong><em>oct</em> <strong>&lt;-&gt;</strong> <em>rpkt</em><strong>&sol;</strong><em>roct</em><strong>) rtt</strong> <em>rtt</em> <strong>ms</strong> [<em>end-reason</em>]</p>
</dd>
</dl>
<p>If present, the payload follows each flow line. Forward direction payload lines 
are prefixed with the string <strong>-&gt;</strong>, and reverse direction payload lines are 
prefixed with the string <strong>&lt;-</strong>. Payload is only taken from the first packet 
for non-TCP flows (see yaf(1)).</p>
<p>
</p>
<h2><a name="tabular_output">Tabular Output</a></h2>
<p>In <strong>--tabular</strong> mode, yafscii prints its output as a table, without a header, 
with one flow per line and no payload information. Each column is separated by 
a pipe character. Columns have constant width and are filled with leading 
zeroes or spaces as appropriate. Every column appears in each row whether it is 
present in the flow data or not; non-present columns are represented with a
<strong>0</strong>. All columns are formatted as they are in the human-readable output, 
except <em>end-time</em> which appears with a data and <em>rtt</em> which is expressed in 
fractional seconds instead of decimal milliseconds. For ICMP flows, ICMP type
and code appear in the <em>dp</em> field, which has the value 256(<em>type</em>) + <em>code</em>.
<em>srcMacAddress</em> and <em>destMacAddress</em> will only print if <strong>--mac</strong> is used.
The order of columns is as follows:</p>
<p><em>start-time</em><strong>|</strong> <em>end-time</em><strong>|</strong> <em>duration</em><strong>|</strong> <em>rtt</em><strong>|</strong>
<em>proto</em><strong>|</strong> <em>sip</em><strong>|</strong> <em>sp</em><strong>|</strong> <em>dip</em><strong>|</strong> <em>dp</em><strong>|</strong>
<em>srcMacAddress</em><strong>|</strong> <em>destMacAddress</em><strong>|</strong> 
<em>iflags</em><strong>|</strong> <em>uflags</em><strong>|</strong> <em>riflags</em><strong>|</strong> <em>ruflags</em><strong>|</strong>
<em>isn</em><strong>|</strong> <em>risn</em><strong>|</strong> <em>tag</em><strong>|</strong> <em>rtag</em><strong>|</strong> <em>pkt</em><strong>|</strong> 
<em>oct</em><strong>|</strong> <em>rpkt</em><strong>|</strong> <em>roct</em><strong>|</strong> <em>applabel</em><strong>|</strong>
<em>entropy</em><strong>|</strong> <em>rentropy</em><strong>|</strong> <em>end-reason</em></p>
<p>
</p>

<h1><a name="signals">SIGNALS</a></h1>
<p>yafscii responds to <strong>SIGINT</strong> or <strong>SIGTERM</strong> by terminating input processing
and exiting.</p>
<p>
</p>

<h1><a name="bugs">BUGS</a></h1>
<p>Known issues are listed in the <strong>README</strong> file in the YAF tools source 
distribution. Note that YAF should be considered alpha-quality software; not 
every conceivable input and option is exhaustively tested at each 
release, and specific features may be completely untested. Please be mindful 
of this before deploying YAF in production environments. YAF's output format 
may also change, as the development of YAF is intended to track progress in 
the IPFIX working group; the file output of YAF should not presently be used 
for archival storage of flow data. Bug reports and feature requests may be 
sent directly to the Network Situational Awareness team at 
&lt;<a href="mailto:netsa-help@cert.org">netsa-help@cert.org</a>&gt;.</p>
<p>
</p>

<h1><a name="authors">AUTHORS</a></h1>
<p>Brian Trammell, Chris Inacio, Michael Duggan, 
and the CERT Network Situational Awareness Group Engineering Team, 
&lt;<a href="http://www.cert.org/netsa">http://www.cert.org/netsa</a>&gt;.</p>
<p>
</p>

<h1><a name="see_also">SEE ALSO</a></h1>
<p><code>yaf(1)</code></p>

      </div><!-- l-content -->
      <div id="l-footer">&copy; 2006-2013 Carnegie Mellon University</div>
    </div><!-- p-body -->
</body>


</html>
