
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>fixbuf- Documentation</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

        <link rel="stylesheet" type="text/css" href="../../site/style.css" />
        <link rel="stylesheet" type="text/css" href="doxygen.css">
        <link rel="stylesheet" type="text/css" href="tabs.css">
</head>
<body>
    <div id="p-body">
      <div id="l-header">
        <img src="../../site/sei-logo.png" id="l-sei-logo"
            alt="Software Engineering Institute | Carnegie Mellon&copy;" />
        <div id="l-netsa-logo"><a id="l-netsa-name" href="../../index.html"><b>CERT NetSA Security Suite</b></a></div>
        <div id="l-netsa-motto">Monitoring for Large-Scale Networks</div>
        <h1 class="l-page-title">fixbuf</h1>
        <span id="l-subtitle">Documentation</span>
      </div><!-- l-header -->
      <div id="l-content">
        <div id="l-sidebar">
          <div class="p-sidebar-section">
            <h1><a href="../index.html">fixbuf</a></h1>
            <ul>
              <li><a href="index.html">Documentation</a></li>
              <li><a href="../download.html">Downloads</a></li>
            </ul>
          </div><!-- p-sidebar-section -->
        </div><!-- l-sidebar -->
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>public.h File Reference</h1>
<p>fixbuf IPFIX protocol library public interface.  
<a href="#_details">More...</a></p>
<code>#include &lt;fixbuf/autoinc.h&gt;</code><br/>

<p><a href="public_8h_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_varfield__st.html">fbVarfield_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A variable-length field value.  <a href="structfb_varfield__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A single IPFIX Information Element definition.  <a href="structfb_info_element__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A single IPFIX Information Element specification.  <a href="structfb_info_element_spec__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_conn_spec__st.html">fbConnSpec_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connection specifier.  <a href="structfb_conn_spec__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_listener_entry__st.html">fbListenerEntry_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ListenerEntry's make up a listener group as a linked list.  <a href="structfb_listener_entry__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_listener_group_result__st.html">fbListenerGroupResult_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ListenerGroupResult's contain the listener who's listening socket got a new connection.  <a href="structfb_listener_group_result__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_listener_group__st.html">fbListenerGroup_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the listeners that are added to the group.  <a href="structfb_listener_group__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_basic_list__st.html">fbBasicList_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A basic list element in a template which structure represents a basic list on the internal side, basic lists in an IPFIX Message must be represented by this structure within the application record.  <a href="structfb_basic_list__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure used to hold information of a sub template list.  <a href="structfb_sub_template_list__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Entries contain the same type of information at SubTemplateLists: template ID and template pointers to describe the data the number of data elements and the data pointer and data length.  <a href="structfb_sub_template_multi_list_entry__st.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_st</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multilists just contain the semantic to describe the sub lists, the number of sub lists, and a pointer to the first entry.  <a href="structfb_sub_template_multi_list__st.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a16875886e559694c2a5d80cc1b9e00de">FB_ERROR_DOMAIN</a>&nbsp;&nbsp;&nbsp;g_quark_from_string(&quot;fixbufError&quot;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All fixbuf errors are returned within the FB_ERROR_DOMAIN domain.  <a href="#a16875886e559694c2a5d80cc1b9e00de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af9fea2f3d2282f4130b0762bfdf4cdc8">FB_ERROR_TMPL</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">No template was available for the given template ID.  <a href="#af9fea2f3d2282f4130b0762bfdf4cdc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0259831c04ac6aeee7cb6c96d76b3d65">FB_ERROR_EOM</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End of IPFIX message.  <a href="#a0259831c04ac6aeee7cb6c96d76b3d65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a367b1a2c0af72830b0c9905b2db317cb">FB_ERROR_EOF</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End of IPFIX Message stream.  <a href="#a367b1a2c0af72830b0c9905b2db317cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa225780afc0e4680caf26e0ec9ab2427">FB_ERROR_IPFIX</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Illegal IPFIX mesaage content on read.  <a href="#aa225780afc0e4680caf26e0ec9ab2427"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2e0ffd43c861a9833b279557d687c57a">FB_ERROR_BUFSZ</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A message was received larger than the collector buffer size.  <a href="#a2e0ffd43c861a9833b279557d687c57a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af25725f494c04fdab230c546953bdda9">FB_ERROR_IMPL</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The requested feature is not yet implemented.  <a href="#af25725f494c04fdab230c546953bdda9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac34f5cab6ec1507f9626c1501b9b8d42">FB_ERROR_IO</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An unspecified I/O error occured.  <a href="#ac34f5cab6ec1507f9626c1501b9b8d42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a11335d44d4833a94788908cc0e019c32">FB_ERROR_NLREAD</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">No data is available for reading from the transport layer.  <a href="#a11335d44d4833a94788908cc0e019c32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6a865a476cfedc1bd762a815a919b3d6">FB_ERROR_NLWRITE</a>&nbsp;&nbsp;&nbsp;9</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An attempt to write data to the transport layer failed due to closure of the remote end of the connection.  <a href="#a6a865a476cfedc1bd762a815a919b3d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac69f7dd9d7d77f5b5a247bdf890f4154"></a><!-- doxytag: member="public.h::FB_ERROR_NOELEMENT" ref="ac69f7dd9d7d77f5b5a247bdf890f4154" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac69f7dd9d7d77f5b5a247bdf890f4154">FB_ERROR_NOELEMENT</a>&nbsp;&nbsp;&nbsp;10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The specified Information Element does not exist in the Information Model. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67ab466e80e9545e35a9adb02b2b977c"></a><!-- doxytag: member="public.h::FB_ERROR_CONN" ref="a67ab466e80e9545e35a9adb02b2b977c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a67ab466e80e9545e35a9adb02b2b977c">FB_ERROR_CONN</a>&nbsp;&nbsp;&nbsp;11</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A connection or association could not be established or maintained. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a85d583572e660442b964f967d6b4e30c">FB_ERROR_NETFLOWV9</a>&nbsp;&nbsp;&nbsp;12</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Illegal NetflowV9 content on a read.  <a href="#a85d583572e660442b964f967d6b4e30c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8196a90e2171e3bf24815f96e736eac"></a><!-- doxytag: member="public.h::FB_ERROR_TRANSMISC" ref="af8196a90e2171e3bf24815f96e736eac" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af8196a90e2171e3bf24815f96e736eac">FB_ERROR_TRANSMISC</a>&nbsp;&nbsp;&nbsp;13</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Miscellaneous error occured during translator operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af98543cbda640dfca398c2d077382a36">FB_IE_INIT</a>(_name_, _ent_, _num_, _len_, _flags_)&nbsp;&nbsp;&nbsp;{{(const struct <a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a>*)_name_}, 0, _ent_, _num_, _len_, _flags_}</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience macro for creating fbInfoElement_t static initializers.  <a href="#af98543cbda640dfca398c2d077382a36"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fc5e825d2eacc9b5f4df103e4bbf1b3"></a><!-- doxytag: member="public.h::FB_IE_NULL" ref="a9fc5e825d2eacc9b5f4df103e4bbf1b3" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9fc5e825d2eacc9b5f4df103e4bbf1b3">FB_IE_NULL</a>&nbsp;&nbsp;&nbsp;FB_IE_INIT(NULL, 0, 0, 0, 0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience macro defining a null information element initializer to terminate a constant information element array for passing to <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a57b7a85944a72f6a16741191eb9458df">FB_IE_F_NONE</a>&nbsp;&nbsp;&nbsp;0x00000000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default treatment flags value.  <a href="#a57b7a85944a72f6a16741191eb9458df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8999778f3785deb0579e458b87671832">FB_IE_F_ENDIAN</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information element endian conversion flag.  <a href="#a8999778f3785deb0579e458b87671832"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af8e002cfbd82eff68afc556f9786c182">FB_IE_F_REVERSIBLE</a>&nbsp;&nbsp;&nbsp;0x00000040</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information element reversible flag.  <a href="#af8e002cfbd82eff68afc556f9786c182"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad5904eae4a46ffa0d02fe24e25bf8f88">FB_IE_F_ALIEN</a>&nbsp;&nbsp;&nbsp;0x00000080</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information element alien flag.  <a href="#ad5904eae4a46ffa0d02fe24e25bf8f88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae155c11f8e5f0a4988170b6997d52489"></a><!-- doxytag: member="public.h::FB_IE_VARLEN" ref="ae155c11f8e5f0a4988170b6997d52489" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae155c11f8e5f0a4988170b6997d52489">FB_IE_VARLEN</a>&nbsp;&nbsp;&nbsp;65535</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information element length constant for variable-length IE. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade3fb2e06562b2f4677d8d6eb2481859"></a><!-- doxytag: member="public.h::FB_IE_BASIC_LIST" ref="ade3fb2e06562b2f4677d8d6eb2481859" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ade3fb2e06562b2f4677d8d6eb2481859">FB_IE_BASIC_LIST</a>&nbsp;&nbsp;&nbsp;291</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information element number constant for basic lists This will change upon updates to the specification. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf07f5462e2e260f899aac2bbf084f21"></a><!-- doxytag: member="public.h::FB_IE_SUBTEMPLATE_LIST" ref="acf07f5462e2e260f899aac2bbf084f21" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acf07f5462e2e260f899aac2bbf084f21">FB_IE_SUBTEMPLATE_LIST</a>&nbsp;&nbsp;&nbsp;292</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information element number constant for sub template lists This will change upon updates to the IPFIX lists specification. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e63e75e26fa69151549b0e359ca85e4"></a><!-- doxytag: member="public.h::FB_IE_SUBTEMPLATE_MULTILIST" ref="a8e63e75e26fa69151549b0e359ca85e4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8e63e75e26fa69151549b0e359ca85e4">FB_IE_SUBTEMPLATE_MULTILIST</a>&nbsp;&nbsp;&nbsp;293</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information element number constant for sub template multi lists This will change upon updates to the IPFIX lists specification. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4e1799c19a4376b5e94a9f2c46af1af0">FB_IE_PEN_REVERSE</a>&nbsp;&nbsp;&nbsp;29305</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Private enterprise number for reverse information elements (see draft-ietf-ipfix-biflow-03 section 6.1).  <a href="#a4e1799c19a4376b5e94a9f2c46af1af0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac0892f774e630526db23f2d4090817c1">FB_IE_VENDOR_BIT_REVERSE</a>&nbsp;&nbsp;&nbsp;0x4000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse information element bit for vendor-specific information elements (see draft-ietf-ipfix-biflow-03 section 6.2).  <a href="#ac0892f774e630526db23f2d4090817c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dd9f74f0b5de011be4ea84cc265d52c"></a><!-- doxytag: member="public.h::FB_CISCO_GENERIC" ref="a6dd9f74f0b5de011be4ea84cc265d52c" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6dd9f74f0b5de011be4ea84cc265d52c">FB_CISCO_GENERIC</a>&nbsp;&nbsp;&nbsp;9999</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic Information Element ID for undefined Cisco NetFlow v9 Elements. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae180698bcf1673599ce689814af51078">FB_CISCO_ASA_EVENT_ID</a>&nbsp;&nbsp;&nbsp;9998</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information Element ID for Cisco NSEL Element NF_F_FW_EVENT often exported by Cisco's ASA Device.  <a href="#ae180698bcf1673599ce689814af51078"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0f1037623125ccfc4f42a08377f61ee1">FB_CISCO_ASA_EVENT_XTRA</a>&nbsp;&nbsp;&nbsp;9997</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information Element ID for Cisco NSEL Element NF_F_FW_EXT_EVENT often exported by Cisco's ASA Device.  <a href="#a0f1037623125ccfc4f42a08377f61ee1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af2a306f4cc41ea9e8d7828cd6c8023fd">FB_IE_REVERSE_STR</a>&nbsp;&nbsp;&nbsp;&quot;reverse&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverse information element name prefix.  <a href="#af2a306f4cc41ea9e8d7828cd6c8023fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac784ef024c2089ce88fe18db93cea70e">FB_IE_REVERSE_STRLEN</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of reverse information element name prefix.  <a href="#ac784ef024c2089ce88fe18db93cea70e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a243165c146a8fbda7e0902a06abce6a4"></a><!-- doxytag: member="public.h::FB_TID_AUTO" ref="a243165c146a8fbda7e0902a06abce6a4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a243165c146a8fbda7e0902a06abce6a4">FB_TID_AUTO</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template ID argument to pass to fbSessionAddTemplate to automatically assign a template ID. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6666b4a09d3125f8a81364f1918db416"></a><!-- doxytag: member="public.h::FB_TID_TS" ref="a6666b4a09d3125f8a81364f1918db416" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6666b4a09d3125f8a81364f1918db416">FB_TID_TS</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserved set ID for template sets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b7738504f6d339b29d5d071b1187d65"></a><!-- doxytag: member="public.h::FB_TID_OTS" ref="a6b7738504f6d339b29d5d071b1187d65" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6b7738504f6d339b29d5d071b1187d65">FB_TID_OTS</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserved set ID for options template sets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae36d9ce926d8c708423062115e429dca"></a><!-- doxytag: member="public.h::FB_TID_MIN_DATA" ref="ae36d9ce926d8c708423062115e429dca" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae36d9ce926d8c708423062115e429dca">FB_TID_MIN_DATA</a>&nbsp;&nbsp;&nbsp;256</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum non-reserved template ID available for data sets. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7f1800b8e6f3d6461798f9c9c6127a1"></a><!-- doxytag: member="public.h::FB_IESPEC_NULL" ref="ae7f1800b8e6f3d6461798f9c9c6127a1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae7f1800b8e6f3d6461798f9c9c6127a1">FB_IESPEC_NULL</a>&nbsp;&nbsp;&nbsp;{ NULL, 0, 0 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience macro defining a null information element specification initializer to terminate a constant information element specifier array for passing to <a class="el" href="public_8h.html#acb8f6399ecdbbc6af8fbacedc4e49a6c" title="Append information elements described by a specifier array to a template.">fbTemplateAppendSpecArray()</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4f6b39310e0db0215096369ffaf342e6">FB_CONNSPEC_INIT</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convenience macro defining a null static fbConnSpec_t.  <a href="#a4f6b39310e0db0215096369ffaf342e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dc3870be25a19efa2940150507aaf71"></a><!-- doxytag: member="public.h::UNDEFINED" ref="a2dc3870be25a19efa2940150507aaf71" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2dc3870be25a19efa2940150507aaf71">UNDEFINED</a>&nbsp;&nbsp;&nbsp;0xFF</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semantic field indicating the value has not been set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9ef3d320609b52ae8ed351d503a7e2f"></a><!-- doxytag: member="public.h::NONE_OF" ref="ab9ef3d320609b52ae8ed351d503a7e2f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab9ef3d320609b52ae8ed351d503a7e2f">NONE_OF</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semantic field for none-of value defined in the spec. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05baeff86169f432de37419169a18fe0"></a><!-- doxytag: member="public.h::EXACTLY_ONE_OF" ref="a05baeff86169f432de37419169a18fe0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a05baeff86169f432de37419169a18fe0">EXACTLY_ONE_OF</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semantic field for exactly-one-of value defined in the spec. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7c941bff2b5ec6863c2d572c2bea1b8"></a><!-- doxytag: member="public.h::ONE_OR_MORE_OF" ref="af7c941bff2b5ec6863c2d572c2bea1b8" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af7c941bff2b5ec6863c2d572c2bea1b8">ONE_OR_MORE_OF</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semantic field for the one-or-more-of value defined in the spec. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3833b6f69f8981762d86b531b70e976"></a><!-- doxytag: member="public.h::ALL_OF" ref="ab3833b6f69f8981762d86b531b70e976" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab3833b6f69f8981762d86b531b70e976">ALL_OF</a>&nbsp;&nbsp;&nbsp;0x03</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semantic field for the all-of value defined in the spec. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4973b1d8a17146954ac40be84823c8b0"></a><!-- doxytag: member="public.h::ORDERED" ref="a4973b1d8a17146954ac40be84823c8b0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4973b1d8a17146954ac40be84823c8b0">ORDERED</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Semantic field for the ordered value defined in the spec. <br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct fBuf_st&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An IPFIX message buffer.  <a href="#ab1479ebe89aecd202bb628c33102129b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_varfield__st.html">fbVarfield_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae4c56b8891012ac69488b0a9558aaf9e">fbVarfield_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A variable-length field value.  <a href="#ae4c56b8891012ac69488b0a9558aaf9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct fbInfoModel_st&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An IPFIX information model.  <a href="#a7403b5635628fcc24eeb03b73c0b08bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8e5e041c0ef22a30e1b916c6284cb180">fbInfoElement_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A single IPFIX Information Element definition.  <a href="#a8e5e041c0ef22a30e1b916c6284cb180"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_template__st.html">fbTemplate_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1a98b02ac2e3547d96e839174270af99">fbTemplate_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An IPFIX Template or Options Template.  <a href="#a1a98b02ac2e3547d96e839174270af99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab31a6d6f2d24c483d1dc3d7cc8f71009">fbInfoElementSpec_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A single IPFIX Information Element specification.  <a href="#ab31a6d6f2d24c483d1dc3d7cc8f71009"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct fbSession_st&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An IPFIX Transport Session state container.  <a href="#a8441ccbdab7eaccc081dae0e3af32855"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">fbTransport_en</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a484fac3d07ebd24f2d165a74973be704">fbTransport_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transport protocol for connection specifier.  <a href="#a484fac3d07ebd24f2d165a74973be704"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_conn_spec__st.html">fbConnSpec_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#abbc3c1c84682e0e8d89280fbe828b392">fbConnSpec_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connection specifier.  <a href="#abbc3c1c84682e0e8d89280fbe828b392"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct fbExporter_st&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IPFIX Exporting Process endpoint.  <a href="#a054d6ae24ecc9fbc2e38e683d8a5481a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct fbCollector_st&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IPFIX Collecting Process endpoint.  <a href="#adbe40eb39792bfedc00d221c8c9f7a15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct fbListener_st&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IPFIX Collecting Process session listener.  <a href="#a4265eb950b491c405d075f1510a5710e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c43c579a9c79c7adc724c223e3d87c3"></a><!-- doxytag: member="public.h::fbListenerEntry_t" ref="a7c43c579a9c79c7adc724c223e3d87c3" args="" -->
typedef struct <a class="el" href="structfb_listener_entry__st.html">fbListenerEntry_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7c43c579a9c79c7adc724c223e3d87c3">fbListenerEntry_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ListenerGroup and associated data type definitions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae51a493368af916fd3bc701cb8e9383"></a><!-- doxytag: member="public.h::fbListenerGroupResult_t" ref="aae51a493368af916fd3bc701cb8e9383" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="structfb_listener_group_result__st.html">fbListenerGroupResult_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aae51a493368af916fd3bc701cb8e9383">fbListenerGroupResult_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">typedef for listener group result <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aceaa1cd50f3da1a883ee1b147c339bb1"></a><!-- doxytag: member="public.h::fbListenerGroup_t" ref="aceaa1cd50f3da1a883ee1b147c339bb1" args="" -->
typedef struct <a class="el" href="structfb_listener_group__st.html">fbListenerGroup_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aceaa1cd50f3da1a883ee1b147c339bb1">fbListenerGroup_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure that holds the listeners that are added to the group. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef gboolean(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa0f87164ee76983beadbf79299681f20">fbAcceptCallback_fn</a> )(<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *buf, <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, struct sockaddr *sAddr, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the callback function to be called when a new connection to a listener has been received.  <a href="#aa0f87164ee76983beadbf79299681f20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a5c72c26427ae0efc734862b95cb09ae9">fbNewTemplateCallback_fn</a> )(<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The callback function to be called when the session receives a new external template from the connected node.  <a href="#a5c72c26427ae0efc734862b95cb09ae9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adda8181e9f5b364e14ed770071eaf7a7"></a><!-- doxytag: member="public.h::fbBasicList_t" ref="adda8181e9f5b364e14ed770071eaf7a7" args="" -->
typedef struct <a class="el" href="structfb_basic_list__st.html">fbBasicList_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#adda8181e9f5b364e14ed770071eaf7a7">fbBasicList_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A basic list element in a template which structure represents a basic list on the internal side, basic lists in an IPFIX Message must be represented by this structure within the application record. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#afb88011d092a7157d3632a6d660294d6">fbSubTemplateList_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure used to hold information of a sub template list.  <a href="#afb88011d092a7157d3632a6d660294d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a21c182c97f40c7c8f213e8e090d9057a">fbSubTemplateMultiListEntry_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Entries contain the same type of information at SubTemplateLists: template ID and template pointers to describe the data the number of data elements and the data pointer and data length.  <a href="#a21c182c97f40c7c8f213e8e090d9057a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba12b242961090c27f20231ba153fb5b"></a><!-- doxytag: member="public.h::fbSubTemplateMultiList_t" ref="aba12b242961090c27f20231ba153fb5b" args="" -->
typedef struct <br class="typebreak"/>
<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_st</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aba12b242961090c27f20231ba153fb5b">fbSubTemplateMultiList_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multilists just contain the semantic to describe the sub lists, the number of sub lists, and a pointer to the first entry. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef gboolean(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1fb1a0bf576fb67a0f42143416dc205c">fbListenerAppInit_fn</a> )(<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, void **ctx, int fd, struct sockaddr *peer, size_t peerlen, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application context initialization function type for fbListener_t.  <a href="#a1fb1a0bf576fb67a0f42143416dc205c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4bfbe8463a351cde3e2e62436721abda">fbListenerAppFree_fn</a> )(void *ctx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Application context free function type for fbListener_t.  <a href="#a4bfbe8463a351cde3e2e62436721abda"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">fbTransport_en</a> { <br/>
&nbsp;&nbsp;<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a7e8c8d5180377a3e0c466dd421a5b541">FB_SCTP</a>, 
<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a3d0d039b439e58056f0318fc8d40f69e">FB_TCP</a>, 
<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a99b2804a276e4d9bb12df356a58249e2">FB_UDP</a>, 
<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a0e089a579ef744ed527b20018e0d2fa9">FB_DTLS_SCTP</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a26085cf8945b1127fe9aa2671544cac8">FB_TLS_TCP</a>, 
<a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a1adfe2d456296749abdd84cc5dcbf997">FB_DTLS_UDP</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Transport protocol for connection specifier. </p>
 <a href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a357399fb037ea9b0b6e0c641a8f40cec">fbListValidSemantic</a> (uint8_t semantic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">validates the value of the semantic field,  <a href="#a357399fb037ea9b0b6e0c641a8f40cec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a682b8bb11a27e75655696a565e588415">fbBasicListAlloc</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">allocates a Basic List Structure  <a href="#a682b8bb11a27e75655696a565e588415"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a97a0558ba604ec339fc908594cdfa74f">fbBasicListInit</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr, uint8_t semantic, const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *infoElement, uint16_t numElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the basic list structure based on the parameters.  <a href="#a97a0558ba604ec339fc908594cdfa74f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac422bc91621366c71eb467ec4181d360">fbBasicListInitWithOwnBuffer</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr, uint8_t semantic, const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *infoElement, uint16_t numElements, uint16_t dataLength, uint8_t *dataPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">use this function to initialize the basic list, but it gets the pointer to a buffer and its length allocated independently from these functions This will generally be used by a collector that does not want to free and allocate new buffers for each incoming message  <a href="#ac422bc91621366c71eb467ec4181d360"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a86efdc19c5c10383737e0de89c97b950">fbBasicListCollectorInit</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This initializes a basic list structure for collection.  <a href="#a86efdc19c5c10383737e0de89c97b950"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab246e008d0cfe758ae98c3ac1d0342d1">fbBasicListGetSemantic</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Semantic field for Basic List presumably used in collectors after decoding.  <a href="#ab246e008d0cfe758ae98c3ac1d0342d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4fcc3e9eed3d8ba2178df3212d7e77f3">fbBasicListSetSemantic</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr, uint8_t semantic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the semantic for describing a basic list generally used in exporters before decoding.  <a href="#a4fcc3e9eed3d8ba2178df3212d7e77f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa7be05a5a0f8e3b16c6ac3bf1f38a982">fbBasicListGetInfoElement</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function returns a pointer to the information element used in the list it is mainly used in collectors to retrieve information.  <a href="#aa7be05a5a0f8e3b16c6ac3bf1f38a982"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a573bcfbfc4697838625af06884466e17">fbBasicListGetDataPtr</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acdd859fd4bc3dc5974b321f0eee2e720">fbBasicListGetIndexedDataPtr</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr, uint16_t bl_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function retrieves the index'th element in the list index is 0-based.  <a href="#acdd859fd4bc3dc5974b321f0eee2e720"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa5cd86fbb92c002a5a29b466c759393e">fbBasicListGetNextPtr</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr, void *currentPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function returns the next element in the list based on the currentPtr.  <a href="#aa5cd86fbb92c002a5a29b466c759393e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2051991d465d885437c30e886bd86c3c">fbBasicListRealloc</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicList, uint16_t newNumElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the current data pointer, allocating a new buffer to accomodate the new number of elements.  <a href="#a2051991d465d885437c30e886bd86c3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4d84288b9feaa32be492448b794a3697">fbBasicListAddNewElements</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicList, uint16_t numNewElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates an additional elememnt into the basic list must be called after calling BasicListInit.  <a href="#a4d84288b9feaa32be492448b794a3697"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae2da02e486b6f9731f33d059cc5d6eca">fbBasicListClear</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the parameters of the basic list and free the data buffer.  <a href="#ae2da02e486b6f9731f33d059cc5d6eca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8d17288918fee8fddd4c1b37fda3d691">fbBasicListClearWithoutFree</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicList)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the parameters of the basic list, but do not free the buffer.  <a href="#a8d17288918fee8fddd4c1b37fda3d691"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aef3712961929af50bc0900c30cbba773">fbBasicListFree</a> (<a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *basicListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the basic list, then free the basic list pointer.  <a href="#aef3712961929af50bc0900c30cbba773"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a929f24a1af3566fc5a57d13ba7d520fc">fbSubTemplateListAlloc</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates a subTemplateList_t Based on how subTemplateLists will be used and set up amidst data structures, this function may never be used.  <a href="#a929f24a1af3566fc5a57d13ba7d520fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a499616fc3525e481de877d726d7ada00">fbSubTemplateListInit</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *sTL, uint8_t semantic, uint16_t tmplID, const <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, uint16_t numElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a subTemplateList structure and alloc's the dataPtr to get a buffer able to hold numElements in the template This will mainly be used in exporters preparing to encode.  <a href="#a499616fc3525e481de877d726d7ada00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af107185a4e7b9bf3ca1c086f3e170831">fbSubTemplateListInitWithOwnBuffer</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateList, uint8_t semantic, uint16_t tmplID, const <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, uint16_t numElements, uint16_t dataLength, uint8_t *dataPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the subTemplateList but does not allocate a buffer.  <a href="#af107185a4e7b9bf3ca1c086f3e170831"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af0f0c40ed3a5bb9f0da695f098b1d0c3">fbSubTemplateListCollectorInit</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *STL)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes a sub template list variable on a collector.  <a href="#af0f0c40ed3a5bb9f0da695f098b1d0c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a91c7e51169df7680c9db96befde9cd74">fbSubTemplateListGetDataPtr</a> (const <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to the buffer that contains the data for the list.  <a href="#a91c7e51169df7680c9db96befde9cd74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#abcc3c1f936517485ba2ed23945273da7">fbSubTemplateListGetIndexedDataPtr</a> (const <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr, uint16_t index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function is used to iterate over the elements in the list by passing in a counter to indicate which element is to be returned.  <a href="#abcc3c1f936517485ba2ed23945273da7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aee412c835fa0ee64eb4a7fc67975e69b">fbSubTemplateListGetNextPtr</a> (const <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr, void *currentPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function also traverses the elements in the list by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element.  <a href="#aee412c835fa0ee64eb4a7fc67975e69b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aea90a84a945c348970d6f24694d761a0">fbSubTemplateListSetSemantic</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr, uint8_t semantic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the semantic parameter of a subTemplateList.  <a href="#aea90a84a945c348970d6f24694d761a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af0f68a07d50e046fde0d1cfb315ca0e7">fbSubTemplateListGetSemantic</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the semantic value from a sub template list.  <a href="#af0f68a07d50e046fde0d1cfb315ca0e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a63643493a19bce4564676fbf6b0294b9">fbSubTemplateListGetTemplate</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the template pointer from the list structure.  <a href="#a63643493a19bce4564676fbf6b0294b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a26cd7af13bdc03147832e868ee3a648f">fbSubTemplateListGetTemplateID</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the template ID for the template used by the list.  <a href="#a26cd7af13bdc03147832e868ee3a648f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2c40d213552ca0d27b9c60ce0fbc1383">fbSubTemplateListRealloc</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateList, uint16_t newNumElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the current data pointer, allocating a new buffer to accomodate the new number of elements.  <a href="#a2c40d213552ca0d27b9c60ce0fbc1383"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1974da5e6837cdfb2d0a17d7efc338ef">fbSubTemplateListAddNewElements</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateList, uint16_t numNewElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates space for a number of additional element in the sub template list must be called after the list has been <a class="el" href="public_8h.html#a499616fc3525e481de877d726d7ada00" title="Initializes a subTemplateList structure and alloc&#39;s the dataPtr to get a buffer...">fbSubTemplateListInit()</a>'d.  <a href="#a1974da5e6837cdfb2d0a17d7efc338ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#adab25ac70317a2b857ef7acea86ae582">fbSubTemplateListClear</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears a subtemplate list struct, notably freeing the dataPtr and setting it to NULL.  <a href="#adab25ac70317a2b857ef7acea86ae582"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad6a97dee08969e092dff301ac73766e7">fbSubTemplateListClearWithoutFree</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the sub template list parameters but does not free the data ptr.  <a href="#ad6a97dee08969e092dff301ac73766e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa724aa4ec311288e02dfab42cf23c355">fbSubTemplateListFree</a> (<a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *subTemplateListPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees and clears a subTemplateList struct.  <a href="#aa724aa4ec311288e02dfab42cf23c355"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a3d3c58aebb9dcb758be9fa7eef314781">fbSubTemplateMultiListInit</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML, uint8_t semantic, uint16_t numElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the multi list with semantic, numbers of elements, and allocates memory to store numElements worth of entries.  <a href="#a3d3c58aebb9dcb758be9fa7eef314781"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4a8185ac0dfdd2535fb338bddbc4948d">fbSubTemplateMultiListSetSemantic</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML, uint8_t semantic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the semantic field for the multi list.  <a href="#a4a8185ac0dfdd2535fb338bddbc4948d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af75970c32e64a7799d61fe32be1ad5c7">fbSubTemplateMultiListGetSemantic</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the semantic paramter from the multi list.  <a href="#af75970c32e64a7799d61fe32be1ad5c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a32b01b970a85e30ab72701da7059ae57">fbSubTemplateMultiListClear</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all of the entries (frees their data pointers), then frees the memory containing the entries.  <a href="#a32b01b970a85e30ab72701da7059ae57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa0c4272a3052cbc6d6385d449f258600">fbSubTemplateMultiListClearEntries</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the memory used by the entries of a sub template multi list NOTE: if any of those entries contain another layer of structures, that second layer must be freed by the user, this function cannot do that.  <a href="#aa0c4272a3052cbc6d6385d449f258600"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab66fd48ac8abd256e4310962aa8c6728">fbSubTemplateMultiListFree</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the multi list, then frees the memory pointed to by STML.  <a href="#ab66fd48ac8abd256e4310962aa8c6728"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8cbfaabfe3526969d1bb61b6b68699a6">fbSubTemplateMultiListRealloc</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML, uint16_t newNumEntries)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the entries used by the multi list, then if newNumElements is different than numElements, frees the entries buffer and allocates a new one.  <a href="#a8cbfaabfe3526969d1bb61b6b68699a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a37ea8ee69f101c7d787c8b64bf76c0b8">fbSubTemplateMultiListAddNewEntries</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML, uint16_t numNewEntries)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds entries to the multi list of entries can only be run after the list has been initialized.  <a href="#a37ea8ee69f101c7d787c8b64bf76c0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2dfe6e3994cd27f0f2c2863cbc9accd6">fbSubTemplateMultiListGetFirstEntry</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the first entry in the multi list.  <a href="#a2dfe6e3994cd27f0f2c2863cbc9accd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8234b166da13c96cc3e70c9ca1c57ba9">fbSubTemplateMultiListGetIndexedEntry</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML, uint16_t index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a pointer to the entry of a specific index.  <a href="#a8234b166da13c96cc3e70c9ca1c57ba9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7e320134f6cbe6bb42cf2ff353b52636">fbSubTemplateMultiListGetNextEntry</a> (<a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *STML, <a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *currentEntry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function also traverses the elements in the list by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element.  <a href="#a7e320134f6cbe6bb42cf2ff353b52636"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ab3d07cd5e507e5ebac4e9ca32c776636">fbSubTemplateMultiListEntryInit</a> (<a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *entry, uint16_t tmplID, <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, uint16_t numElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the multi list entry with the template values, and allocates the memory used by the entry to hold the data.  <a href="#ab3d07cd5e507e5ebac4e9ca32c776636"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8b35725d9ae682581eaba7bb5f1caefb">fbSubTemplateMultiListEntryRealloc</a> (<a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *entry, uint16_t newNumElements)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees the memory for the data used by the entry, then allocates a new buffer based on the size of the template and newNumElements.  <a href="#a8b35725d9ae682581eaba7bb5f1caefb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aab5362c194595441d9b3cf96f1d92a0d">fbSubTemplateMultiListEntryClear</a> (<a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees the memory pointed to by the data buffer holding the data elements.  <a href="#aab5362c194595441d9b3cf96f1d92a0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acb3325df690ba3bff4cb9b691a5fe307">fbSubTemplateMultiListEntryGetDataPtr</a> (<a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the data pointer for this entry.  <a href="#acb3325df690ba3bff4cb9b691a5fe307"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1bb644017749befbc7337a9839642ad5">fbSubTemplateMultiListEntryNextDataPtr</a> (<a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *entry, void *currentPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function traverses the elements in the entry by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element.  <a href="#a1bb644017749befbc7337a9839642ad5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af1152a67d46b10b2f0a6550506f06d02">fbSubTemplateMultiListEntryGetIndexedPtr</a> (<a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *entry, uint16_t index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pointer to a data element in the entry based on the index.  <a href="#af1152a67d46b10b2f0a6550506f06d02"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a27841bb33f91bbf856c49cd1c0ee32d9">fbSubTemplateMultiListEntryGetTemplate</a> (<a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the template pointer used to structure the data elements.  <a href="#a27841bb33f91bbf856c49cd1c0ee32d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a87c7ce2b006144807f49d6388309d983">fbSubTemplateMultiListEntryGetTemplateID</a> (<a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the template ID for the template used to structure the data.  <a href="#a87c7ce2b006144807f49d6388309d983"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a68c450b3579f5a1fa3c862a647eaa704">fbListenerGroupAlloc</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates and returns a fbListenerGroup with no entries.  <a href="#a68c450b3579f5a1fa3c862a647eaa704"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a5b5716c8fe63a2f982e32a98eed0e38f">fbListenerGroupAddListener</a> (<a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a> *group, const <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a previously allocated listener to the previously allocated group.  <a href="#a5b5716c8fe63a2f982e32a98eed0e38f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acb9f0add5b127eb4f68270f56b65bc97">fbListenerGroupDeleteListener</a> (<a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a> *group, const <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes the listener from the group.  <a href="#acb9f0add5b127eb4f68270f56b65bc97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_listener_group_result__st.html">fbListenerGroupResult_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a10d092063e0986f7fab4444fa0f65822">fbListenerGroupWait</a> (<a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a> *group, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to fbListenerWait, except that is looks for connections for multiple listeners.  <a href="#a10d092063e0986f7fab4444fa0f65822"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a98291cffaaf2b8a611647a5267c00c64">fbListenerWaitAcceptCallback</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, <a class="el" href="public_8h.html#aa0f87164ee76983beadbf79299681f20">fbAcceptCallback_fn</a> callback, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes one listener, and instead of returning the fBuf created from the new collector, like <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a>, it calls the callback function provided.  <a href="#a98291cffaaf2b8a611647a5267c00c64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1357c6b501f4b1823051e3d4a9f90af7">fbListenerGroupWaitAcceptCallback</a> (<a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a> *group, <a class="el" href="public_8h.html#aa0f87164ee76983beadbf79299681f20">fbAcceptCallback_fn</a> callback, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A combination of ListenerGroupWait and ListenerWaitAcceptCallback.  <a href="#a1357c6b501f4b1823051e3d4a9f90af7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#abc226a9f5cef7f773fe55817839179d0">fbListenerOwnSocketCollectorTCP</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, int sock, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an fBuf wrapped around an independently managed socket and a properly created listener for TCP connections.  <a href="#abc226a9f5cef7f773fe55817839179d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a3048c8b45e2d66218eaf97b2c45fdea0">fbListenerOwnSocketCollectorTLS</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, int sock, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as fbListenerOwnSocketCollectorTCP but for TLS (not tested).  <a href="#a3048c8b45e2d66218eaf97b2c45fdea0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aaa42fa37b56ab10897b0374360d1a401">fBufInterruptSocket</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupts the select call of a specific collector by way of its fBuf.  <a href="#aaa42fa37b56ab10897b0374360d1a401"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a28c6c56234351a793fd513b212bd31b8">fBufSetInternalTemplate</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint16_t int_tid, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the internal template on a buffer to the given template ID.  <a href="#a28c6c56234351a793fd513b212bd31b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#af6cd20b1eb9a3287f17587888ee2476b">fBufSetExportTemplate</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint16_t ext_tid, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the external template for export on a buffer to the given template ID.  <a href="#af6cd20b1eb9a3287f17587888ee2476b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a661f4cc21e726345d3e22372af33c2d1">fBufSetAutomaticMode</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, gboolean automatic)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the automatic mode flag on a buffer.  <a href="#a661f4cc21e726345d3e22372af33c2d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0181c5c031ec9b081149d16bab6ac5e4">fBufGetSession</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the session associated with a buffer.  <a href="#a0181c5c031ec9b081149d16bab6ac5e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a064ee09c33f86ac3b4e87320c2ae6463">fBufFree</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a buffer.  <a href="#a064ee09c33f86ac3b4e87320c2ae6463"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2fb7c1a2229e3e8c15c04a215c92329b">fBufAllocForExport</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new buffer for export.  <a href="#a2fb7c1a2229e3e8c15c04a215c92329b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa1569a4ca87dc52a3bb70082a2f79eb8">fBufGetExporter</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the exporting process endpoint associated with a buffer.  <a href="#aa1569a4ca87dc52a3bb70082a2f79eb8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#afbcd8b28b9e9e51c1a0ce342024b86ef">fBufSetExporter</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, <a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate an exporting process endpoint with a buffer.  <a href="#afbcd8b28b9e9e51c1a0ce342024b86ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6">fBufAppend</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint8_t *recbase, size_t recsize, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append a record to a buffer.  <a href="#ad3fdaa8626ff753c5b617707698c22b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1">fBufEmit</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Emit the message currently in a buffer using the associated exporting process endpoint.  <a href="#a3def007c235fd0dccb7a2293b23341e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aff8d9e237f95baf75040575af0df2962">fBufSetExportTime</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint32_t extime)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the export time on the message currently in a buffer.  <a href="#aff8d9e237f95baf75040575af0df2962"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a71b2a64c7d212e9c3562388b95b993ab">fBufAllocForCollection</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new buffer for collection.  <a href="#a71b2a64c7d212e9c3562388b95b993ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1557695deee79d0e3d053b2eda559aa8">fBufGetCollector</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the collecting process endpoint associated with a buffer.  <a href="#a1557695deee79d0e3d053b2eda559aa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae808992140071be1ccbb258ea012efd0">fBufSetCollector</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate an collecting process endpoint with a buffer.  <a href="#ae808992140071be1ccbb258ea012efd0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7">fBufNext</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint8_t *recbase, size_t *recsize, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a record from a buffer.  <a href="#a11c40f1d55e2d4b29b40eb4c07ce5ee7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479">fBufNextMessage</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a new message into a buffer using the associated collecting process endpoint.  <a href="#a7c89ee8cc9d536e1ceafb371513a6479"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a5bd3a50bb441990a1d9ae7483595578b">fBufGetExportTime</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the export time on the message currently in a buffer.  <a href="#a5bd3a50bb441990a1d9ae7483595578b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a04878018c9b5d07cf7bae316da654007">fBufGetCollectionTemplate</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint16_t *ext_tid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the external template used to read the last record from the buffer.  <a href="#a04878018c9b5d07cf7bae316da654007"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0be7af99ed60994dbbcfbc16701a4ace">fBufNextCollectionTemplate</a> (<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *fbuf, uint16_t *ext_tid, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the external template that will be used to read the next record from the buffer.  <a href="#a0be7af99ed60994dbbcfbc16701a4ace"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a390f707c7decf65060f31c0dba6c2a97">fbInfoModelAlloc</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new information model.  <a href="#a390f707c7decf65060f31c0dba6c2a97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a860639c9f5bdf973a8c303aa9f513454">fbInfoModelFree</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free an information model.  <a href="#a860639c9f5bdf973a8c303aa9f513454"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0">fbInfoModelAddElement</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *ie)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a single information element to an information model.  <a href="#ae06a524366afa6827d7e5abb1c33c0d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179">fbInfoModelAddElementArray</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *ie)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add multiple information elements in an array to an information model.  <a href="#a202bfa2340263229893a38de18670179"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a5dc8b2e255bc36ca22abbb811bf85c20">fbInfoModelGetElementByName</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the canonical information element within an information model given the information element name.  <a href="#a5dc8b2e255bc36ca22abbb811bf85c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a507dc0fe44ee38bab3fb2c29917d5d08">fbInfoModelGetElementByID</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model, uint16_t id, uint32_t ent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a pointer to the canonical information element within an information model given the information element ID and enterprise ID.  <a href="#a507dc0fe44ee38bab3fb2c29917d5d08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a6dad36eadf23739de4fe77ae466c0c7d">fbTemplateAlloc</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a new empty template.  <a href="#a6dad36eadf23739de4fe77ae466c0c7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a06ca9d2de7767f09ddcaa50651ff5b7c">fbTemplateAppend</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *ex_ie, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an information element to a template.  <a href="#a06ca9d2de7767f09ddcaa50651ff5b7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a3507ead494bd3957d325565c66660e79">fbTemplateAppendSpec</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, <a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_t</a> *spec, uint32_t flags, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an information element described by specifier to a template.  <a href="#a3507ead494bd3957d325565c66660e79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#acb8f6399ecdbbc6af8fbacedc4e49a6c">fbTemplateAppendSpecArray</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, <a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_t</a> *spec, uint32_t flags, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append information elements described by a specifier array to a template.  <a href="#acb8f6399ecdbbc6af8fbacedc4e49a6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae789e65af95fb99fcab61474288104ce">fbTemplateCountElements</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine number of information elements in a template.  <a href="#ae789e65af95fb99fcab61474288104ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9c24d42f54d9f367db257e2d0df9b451">fbTemplateSetOptionsScope</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, uint16_t scope_count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the number of information elements in a template that are scope.  <a href="#a9c24d42f54d9f367db257e2d0df9b451"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a363e2261bf5a74d6efe0f64b19602454">fbTemplateGetOptionsScope</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine number of scope information elements in a template.  <a href="#a363e2261bf5a74d6efe0f64b19602454"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a12f92cdd32c7b3d3b2cd868169e94df9">fbTemplateContainsElement</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *ex_ie)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a template contains a given information element.  <a href="#a12f92cdd32c7b3d3b2cd868169e94df9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#afefdba7c60efb314f90945a4c3871990">fbTemplateContainsElementByName</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, <a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_t</a> *spec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a template contains at least one instance of a given information element, specified by name in the template's information model.  <a href="#afefdba7c60efb314f90945a4c3871990"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a77d6b67bc472d0c5d9519705e4762b0b">fbTemplateContainsAllElementsByName</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, <a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_t</a> *spec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if a template contains at least one instance of each information element in a given information element specifier array.  <a href="#a77d6b67bc472d0c5d9519705e4762b0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0876c0ada0d62b708c7e202c18011380">fbTemplateFreeUnused</a> (<a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a template if it is not currently in use by any Session.  <a href="#a0876c0ada0d62b708c7e202c18011380"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ace1d8a4523d098e625d5330e0d15bd4b">fbSessionAlloc</a> (<a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *model)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a transport session state container.  <a href="#ace1d8a4523d098e625d5330e0d15bd4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a571e85ca2f6c01b1c94932e546b978e9">fbSessionAddTemplateCallback</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#a5c72c26427ae0efc734862b95cb09ae9">fbNewTemplateCallback_fn</a> callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function sets the callback to let the user know when a new template has arrived from the connected IPFIX node.  <a href="#a571e85ca2f6c01b1c94932e546b978e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1b142aa40a63aab16b297c77649f3d5c">fbSessionAddTemplatePair</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t ent_tid, uint16_t int_tid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an external-internal template pair to the session.  <a href="#a1b142aa40a63aab16b297c77649f3d5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ae285ec588b2c18d3e57ff92ee4090ce5">fbSessionRemoveTemplatePair</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t ext_tid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">remove a template pair from the list this is called by fixbuf when a template is revoked from the session by the node on the other end of the connection  <a href="#ae285ec588b2c18d3e57ff92ee4090ce5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7d63552a3f19493ec9e05c6826f3a6ed">fbSessionLookupTemplatePair</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t ext_tid)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function to find a pair, uniquely identified by the external ID, and return the associated internal template ID.  <a href="#a7d63552a3f19493ec9e05c6826f3a6ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4d6672c72da8b767025ff9bd5bb54a82">fbSessionFree</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a transport session state container.  <a href="#a4d6672c72da8b767025ff9bd5bb54a82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac7ebb73e4655052664d69e9b1876543d">fbSessionResetExternal</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the external state (sequence numbers and templates) in a session state container.  <a href="#ac7ebb73e4655052664d69e9b1876543d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a80f2a7b352786c72e05738a5f1d4f293">fbSessionSetDomain</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint32_t domain)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the current observation domain on a session.  <a href="#a80f2a7b352786c72e05738a5f1d4f293"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4b4577b6072c238c6d56f08555191ebb">fbSessionGetDomain</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the current domain on a session.  <a href="#a4b4577b6072c238c6d56f08555191ebb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9236bdb53a94cd19bad3fef2c9bfb947">fbSessionExportTemplate</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Export a single external template in the current domain of a given session.  <a href="#a9236bdb53a94cd19bad3fef2c9bfb947"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4e0c42fc80985c048190203257697ab6">fbSessionExportTemplates</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Export all external templates in the current domain of a given session.  <a href="#a4e0c42fc80985c048190203257697ab6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2e4baf6d2142eca4cb526b1e80628bf8">fbSessionAddTemplate</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, gboolean internal, uint16_t tid, <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a template to a session.  <a href="#a2e4baf6d2142eca4cb526b1e80628bf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a26aa6df19f1e9118c957d2b2359021d0">fbSessionRemoveTemplate</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, gboolean internal, uint16_t tid, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a template from a session.  <a href="#a26aa6df19f1e9118c957d2b2359021d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0bf0ea7e68b9e58aa3fe8e0fbdc1e713">fbSessionGetTemplate</a> (<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, gboolean internal, uint16_t tid, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve a template from a session by ID.  <a href="#a0bf0ea7e68b9e58aa3fe8e0fbdc1e713"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a56ccd30ae0534e838107d39769b8f9f9">fbExporterAllocNet</a> (<a class="el" href="structfb_conn_spec__st.html">fbConnSpec_t</a> *spec)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an exporting process endpoint for a network connection.  <a href="#a56ccd30ae0534e838107d39769b8f9f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8b159cd95821b4382a04543f18faa279">fbExporterAllocFile</a> (const char *path)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an exporting process endpoint for a named file.  <a href="#a8b159cd95821b4382a04543f18faa279"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a4055c4e29d7358629373e2be2a89a4dd">fbExporterAllocFP</a> (FILE *fp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate an exporting process endpoint for an opened ANSI C file pointer.  <a href="#a4055c4e29d7358629373e2be2a89a4dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a8d7419bcb555dba21cba184f7ce50086">fbExporterSetStream</a> (<a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter, int sctp_stream)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the SCTP stream for the next message exported.  <a href="#a8d7419bcb555dba21cba184f7ce50086"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a809156340bdb9a1003ad57114eef5e0b">fbExporterAutoStream</a> (<a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable automatic SCTP stream selection for the next message exported.  <a href="#a809156340bdb9a1003ad57114eef5e0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac91f3ef3a469b8ec03eb195e70dbc16f">fbExporterClose</a> (<a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *exporter)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Force the file or socket underlying an exporting process endpoint to close.  <a href="#ac91f3ef3a469b8ec03eb195e70dbc16f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7549b8dcc9e44f02187708cfb36d14bc">fbCollectorAllocFile</a> (void *ctx, const char *path, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a collecting process endpoint for a named file.  <a href="#a7549b8dcc9e44f02187708cfb36d14bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a9891f65a4f6d838152b92c7afe97cc8d">fbCollectorAllocFP</a> (void *ctx, FILE *fp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a collecting process endpoint for an open file.  <a href="#a9891f65a4f6d838152b92c7afe97cc8d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ad9fa506279884348752111ff3bb52882">fbCollectorGetContext</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the application context associated with a collector.  <a href="#ad9fa506279884348752111ff3bb52882"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aef460934e9c8a4fe3530cf06f66ea3cb">fbCollectorClose</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close the file or socket underlying a collecting process endpoint.  <a href="#aef460934e9c8a4fe3530cf06f66ea3cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#ac39b5a9a1eb9e8c8feaa9922cf73b300">fbCollectorSetAcceptOnly</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, struct sockaddr *address, size_t address_length)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the collector to only receive from the given IP address over UDP.  <a href="#ac39b5a9a1eb9e8c8feaa9922cf73b300"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048">fbListenerAlloc</a> (<a class="el" href="structfb_conn_spec__st.html">fbConnSpec_t</a> *spec, <a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, <a class="el" href="public_8h.html#a1fb1a0bf576fb67a0f42143416dc205c">fbListenerAppInit_fn</a> appinit, <a class="el" href="public_8h.html#a4bfbe8463a351cde3e2e62436721abda">fbListenerAppFree_fn</a> appfree, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate a listener.  <a href="#a68a2e34a62fbfe7fe37dffa8b6b05048"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aceb413ad5afd11a0437b583f922eb70a">fbListenerFree</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free a listener.  <a href="#aceb413ad5afd11a0437b583f922eb70a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42">fbListenerWait</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on a listener.  <a href="#a514187cc62c75d4ed92ae2e497d21a42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a0d0fd5679efb1df055c72cfc10189363">fbListenerWaitNoCollectors</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for an incoming connection, just like fbListenerWait, except that this function doesn't monitor active collectors.  <a href="#a0d0fd5679efb1df055c72cfc10189363"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7efdc23863fcb2725c6d29c575fcbaa7">fbListenerInterrupt</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cause the current or next call to fbListenerWait to unblock and return.  <a href="#a7efdc23863fcb2725c6d29c575fcbaa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a7e64858b1a8766f7e2889b1de70fca97">fbListenerGetCollector</a> (<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> **collector, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fbListenerGetCollector  <a href="#a7e64858b1a8766f7e2889b1de70fca97"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a52d8b5f0c77c81fb9c67e3509418d724">fbCollectorClearTranslator</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fbCollectorClearTranslator  <a href="#a52d8b5f0c77c81fb9c67e3509418d724"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gboolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#aa751f591a9ae4cd4a46c57f11798a592">fbCollectorSetNetflowV9Translator</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, GError **err)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fbCollectorSetNetflowV9Translator  <a href="#aa751f591a9ae4cd4a46c57f11798a592"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a09cc8db0d961b61a5087c5b107b8c1eb">fbCollectorGetNetflowMissed</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, struct sockaddr *peer, size_t peerlen, uint32_t obdomain)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">fbCollectorGetNetflowMissed  <a href="#a09cc8db0d961b61a5087c5b107b8c1eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct sockaddr *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a85c920e8f0a74ca9ea1d4a40386d673f">fbCollectorGetPeer</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves information about the node connected to this collector.  <a href="#a85c920e8f0a74ca9ea1d4a40386d673f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a68260b0fb1b7947f6a76152a7c4cb6c1">fbCollectorGetObservationDomain</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the observation domain of the node connected to the collector.  <a href="#a68260b0fb1b7947f6a76152a7c4cb6c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a1b18e9e1ccb41a90189125042c952de9">fbCollectorSetUDPMultiSession</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, gboolean multi_session)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attempt to maintain backwards compatibility with UDP.  <a href="#a1b18e9e1ccb41a90189125042c952de9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="public_8h.html#a2efc61d324cb411b9a4c32acff0bc72c">fbCollectorManageUDPStreamByPort</a> (<a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *collector, gboolean manage_port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An attempt to fix what some netflow v9 exporters do wrong.  <a href="#a2efc61d324cb411b9a4c32acff0bc72c"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>fixbuf IPFIX protocol library public interface. </p>
<p>Include <a class="el" href="public_8h.html" title="fixbuf IPFIX protocol library public interface.">fixbuf/public.h</a> in order to use the public fixbuf API. Calls defined in this header file will not change from version to version after fixbuf 1.0.0.</p>
<p>This documentation uses IPFIX terminology as defined in RFC 5101, "Specification of the IPFIX Protocol for the Exchange of IP Traffic Flow
 Information"</p>
<h2><a class="anchor" id="types">
Data Types</a></h2>
<p>This file defines the data types and routines required to support IPFIX Exporting Process and IPFIX Collecting Process creation. Each data type is manipulated primarily by routines named "fb" followed by the type name (e.g., "Session", "Collector") followed by a description of the routine's action. The routines operating on the fBuf_t IPFIX Mesaage buffer type are named beginning with "fBuf".</p>
<p>The fBuf_t opaque type implements a transcoding IPFIX Message buffer for both export and collection, and is the "core" interface to the fixbuf library.</p>
<p>The fbInfoModel_t opaque type implements an IPFIX Information Model, including both IANA managed Information Elements and vendor-specific Information Elements. The fbTemplate_t opaque type implements an IPFIX Template or an IPFIX Options Template. Both are defined in terms of Information Elements, represented by the fbInfoElement_t public type. An fBuf_t message buffer maintains internal Templates, which represent records within the fixbuf application client, and external Templates, which represent records as they appear on the wire, for use during transcoding. For a Spread Exporter, Templates are managed per group. For a Spread Collector, Templates are managed per Session.</p>
<p>The state of an IPFIX Transport Session, including IPFIX Message Sequence Number tracking and the internal and external Templates in use within the Session, are maintained by the fbSession_t opaque type.</p>
<p>An Exporting Process' connection to its corresponding Collecting Process is encapsulated by the fbExporter_t opaque type. Exporters may be created to connect via the network using one of the supported IPFIX transport protocols, or to write to IPFIX Files specified by name or by open ANSI C file pointer.</p>
<p>A Collecting Process' connection to a corresponding Exporting Process is encapsulated by the fbCollector_t opaque type. The passive connection used to listen for connections from Exporting Processes is managed by the fbListener_t opaque type; Collectors can be made to read from IPFIX Files specified directly by name or by open ANSI C file pointer, as well.</p>
<p>Network addresses are specified for Exporters, Collectors, and Listeners using the fbConnSpec_t and fbTransport_t public types.</p>
<p>This file also defines the GError error codes used by all the fixbuf types and routines within the FB_ERROR_DOMAIN domain.</p>
<h2><a class="anchor" id="export">
Exporter Usage</a></h2>
<p>Each fixbuf application must have a single fbInfoModel_t instance that represents the Information Elements that the application understands. The <a class="el" href="public_8h.html#a390f707c7decf65060f31c0dba6c2a97" title="Allocate a new information model.">fbInfoModelAlloc()</a> call allocates a new Information Model with the IANA-managed information elements (current as of the fixbuf release date) preloaded. Additional vendor-specific information elements may be added with <a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0" title="Add a single information element to an information model.">fbInfoModelAddElement()</a> and <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a>.</p>
<p>To create an Exporter, first create an fbSession_t attached to the application's fbInfoModel_t to hold the Exporter's Transport Session state using <a class="el" href="public_8h.html#ace1d8a4523d098e625d5330e0d15bd4b" title="Allocate a transport session state container.">fbSessionAlloc()</a>. If exporting via the Spread protocol, create an fbSpreadParams_t and set its session to your newly defined session, group names (a null terminated array), and Spread daemon name.</p>
<p>Then create an fbExporter_t to encapsulate the connection to the Collecting Process or the file on disk, using the <a class="el" href="public_8h.html#a4055c4e29d7358629373e2be2a89a4dd" title="Allocate an exporting process endpoint for an opened ANSI C file pointer.">fbExporterAllocFP()</a>, <a class="el" href="public_8h.html#a8b159cd95821b4382a04543f18faa279" title="Allocate an exporting process endpoint for a named file.">fbExporterAllocFile()</a>, <a class="el" href="public_8h.html#a56ccd30ae0534e838107d39769b8f9f9" title="Allocate an exporting process endpoint for a network connection.">fbExporterAllocNet()</a>, or fbExporterAllocSpread() calls.</p>
<p>With an fbSession_t and an fbExporter_t available, create a buffer for writing via <a class="el" href="public_8h.html#a2fb7c1a2229e3e8c15c04a215c92329b" title="Allocate a new buffer for export.">fBufAllocForExport()</a>. Set the internal and external template IDs with <a class="el" href="public_8h.html#a28c6c56234351a793fd513b212bd31b8" title="Set the internal template on a buffer to the given template ID.">fBufSetInternalTemplate()</a> and <a class="el" href="public_8h.html#af6cd20b1eb9a3287f17587888ee2476b" title="Set the external template for export on a buffer to the given template ID.">fBufSetExportTemplate()</a>, and use <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a> to write records into IPFIX Messages and Messages to the output stream.</p>
<p>Create and populate templates for addition to this session using the fbTemplate calls, then add them to the session via <a class="el" href="public_8h.html#a2e4baf6d2142eca4cb526b1e80628bf8" title="Add a template to a session.">fbSessionAddTemplate()</a>. If exporting via Spread, before calling <a class="el" href="public_8h.html#a2e4baf6d2142eca4cb526b1e80628bf8" title="Add a template to a session.">fbSessionAddTemplate()</a>, set the group that should receive this template with the fBufSetSpreadExportGroup() call. If more than 1 group should receive the template, use the fbSessionAddTemplatesMulticast() which will call fBufSetSpreadExportGroup() on the given group(s) multicast the template to the given group(s). For Spread, do not use <a class="el" href="public_8h.html#a2e4baf6d2142eca4cb526b1e80628bf8" title="Add a template to a session.">fbSessionAddTemplate()</a> to send to multiple groups.</p>
<p>Note that Templates use internal reference counting, so they may be added to multiple sessions, or to the same session using multiple template IDs or multiple domains, or as both an internal and an external template on the same session.</p>
<p>By default, <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a> will emit an IPFIX Message to the output stream when the end of the message buffer is reached on write. The <a class="el" href="public_8h.html#a661f4cc21e726345d3e22372af33c2d1" title="Set the automatic mode flag on a buffer.">fBufSetAutomaticMode()</a> call can be used to modify this behavior, causing <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a> to return FB_ERROR_EOM when at end of message. Use this if your application requires manual control of message export. In this case, <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint...">fBufEmit()</a> will emit a Message to the output stream. If using Spread, call fBufSetSpreadExportGroup() to set the groups to export to on the buffer before calling <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a>.</p>
<h2><a class="anchor" id="read">
Collector Usage - Reading from IPFIX Files</a></h2>
<p>Using fixbuf to read from IPFIX Files as a Collecting Process is very much like the Export case. Create an fbInfoModel_t and an fbSession_t as above, though you should not define external templates in the new session for collection (instead requiring them to be loaded from templates in the file).</p>
<p>Then create an fbCollector_t to encapsulate the file, using the <a class="el" href="public_8h.html#a9891f65a4f6d838152b92c7afe97cc8d" title="Allocate a collecting process endpoint for an open file.">fbCollectorAllocFP()</a> or <a class="el" href="public_8h.html#a7549b8dcc9e44f02187708cfb36d14bc" title="Allocate a collecting process endpoint for a named file.">fbCollectorAllocFile()</a> calls.</p>
<p>With an fbSession_t and an fbCollector_t available, create a buffer for writing via <a class="el" href="public_8h.html#a71b2a64c7d212e9c3562388b95b993ab" title="Allocate a new buffer for collection.">fBufAllocForCollection()</a>. Set the internal template ID with <a class="el" href="public_8h.html#a28c6c56234351a793fd513b212bd31b8" title="Set the internal template on a buffer to the given template ID.">fBufSetInternalTemplate()</a>, and use <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a> to read records from IPFIX Messages and Messages from the input stream.</p>
<p>By default, <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a> will consume an IPFIX Message from the input stream when the end of the message buffer is reached on read. The <a class="el" href="public_8h.html#a661f4cc21e726345d3e22372af33c2d1" title="Set the automatic mode flag on a buffer.">fBufSetAutomaticMode()</a> call can be used to modify this behavior, causing <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a> to return FB_ERROR_EOM when at end of message. Use this if your application requires manual control of message collection. In this case, <a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479" title="Read a new message into a buffer using the associated collecting process endpoint...">fBufNextMessage()</a> will consume a Message from the input stream.</p>
<h2><a class="anchor" id="collect">
Collector Usage - Listening to the Network</a></h2>
<p>An additional type, fbListener_t, is used to build Collecting Processes to listen for connections from IPFIX Exporting Processes via the network. To use a listener, first create an fbInfoModel_t and an fbSession_t as above, without defining any external templates. Instead of maintaining state for a particular Transport Session, this fbSession_t instance will be used as a template for each Transport Session created by the listener.</p>
<p>Then create an fbListener_t to encapsulate a passive socket on the network to wait for connections from Exporting Processes using the <a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048" title="Allocate a listener.">fbListenerAlloc()</a> call.</p>
<p>To wait for a connection from an Exporting Process, call <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a>, which handles the cloning of the fbSession_t, the creation of the fbCollector_t, and the creation of the buffer for reading from that collector, and returns the newly created fBuf_t instance.</p>
<p>Each listener tracks every active collector/buffer (i.e., each active Session) it created; the <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a> call will return an fBuf_t from which another IPFIX Message may be read if no new connections are available. The preferred parameter may be used to request an fBuf_t to try first, to minimize switching among available Sessions. See the documentation for <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a> for more details.</p>
<h2><a class="anchor" id="udp">
- IPFIX over UDP</a></h2>
<p>It is not recommended to use UDP for IPFIX transport, since UDP is not a reliable transport protocol, and therefore cannot guarantee the delivery ofmessages. libfixbuf stores sequence numbers and reports protential loss of messages. Templates over UDP must be re-sent at regular intervals. Fixbuf does not automatically retransmit messages at regular intervals, it is left to the application author to call <a class="el" href="public_8h.html#a4e0c42fc80985c048190203257697ab6" title="Export all external templates in the current domain of a given session.">fbSessionExportTemplates()</a>. In accordance with RFC 5101, the templates should be resent at least three times in the Template refresh timeout period. Make sure the record size does not exceed the path MTU. libfixbuf will return an error if the message exceeds the path MTU.</p>
<p>A UDP collector session is associated with a unique IP, observation domain pair. UDP sessions timeout after 30 minutes of inactivity. When a session times out, all templates and state are discarded, this includes any related NetFlow v9 templates and/or state. libfixbuf will discard any data records for which it does not contain a template for. Template IDs are unique per UDP session (IP and Observation Domain.) Once templates are refreshed, old templates may not be used or referenced by the collecting session. A UDP collector manages multiple sessions on one collector and fbuf. If the application is using the fbListenerAppInit and fbListenerAppFree functions to maintain context per session, it is necessary to call <a class="el" href="public_8h.html#ad9fa506279884348752111ff3bb52882" title="Retrieve the application context associated with a collector.">fbCollectorGetContext()</a> after each call to <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a> to receive the correct ctx pointer (as opposed to calling it after <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a> returns in the TCP case). If the application needs to manage context PER SESSION, the application must turn on multi-session mode w/ <a class="el" href="public_8h.html#a1b18e9e1ccb41a90189125042c952de9" title="Attempt to maintain backwards compatibility with UDP.">fbCollectorSetUDPMultiSession()</a> (this allows for backwards compatibility with old applications.) Previously, the appinit() function was called only from <a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048" title="Allocate a listener.">fbListenerAlloc()</a> for UDP connections, which did not allow the application the peer information. The appinit() function is now called during <a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048" title="Allocate a listener.">fbListenerAlloc()</a> (with a NULL peer address) and also when a new UDP connection is made to the collector, giving the application veto power over session creation. If the application does not call <a class="el" href="public_8h.html#a1b18e9e1ccb41a90189125042c952de9" title="Attempt to maintain backwards compatibility with UDP.">fbCollectorSetUDPMultiSession()</a>, the application will not receive the callback to it's appinit() function, which only allows the application to set one ctx pointer on all sessions. Likewise, appfree() is only called once, when the collector is freed, if not in multi-session mode. If the application is in multi-session mode, appfree() will be called once for each session when the collector is freed AND anytime a session is timed out.</p>
<p>Note: If the appinit() function returns FALSE, libfixbuf will reject any subsequent messages from the peer address, observation domain until the timeout period has expired.</p>
<p>To only accept IPFIX from one host without using the appinit() and appfree() functions, it is encouraged to use <a class="el" href="public_8h.html#ac39b5a9a1eb9e8c8feaa9922cf73b300" title="Set the collector to only receive from the given IP address over UDP.">fbCollectorSetAcceptOnly()</a>. UDP messages received from other hosts will return FB_ERROR_NLREAD. The application should ignore errors with this error code by clearing the error and calling <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a>.</p>
<p>To manage netflow v9 and UDP sessions by port as well as IP and observation domain, use <a class="el" href="public_8h.html#a2efc61d324cb411b9a4c32acff0bc72c" title="An attempt to fix what some netflow v9 exporters do wrong.">fbCollectorManageUDPStreamByPort()</a>. Some netflow v9 devices send two separate streams from different ports to the same sensor. Unless the observation domain is different on each of the streams, use <a class="el" href="public_8h.html#a2efc61d324cb411b9a4c32acff0bc72c" title="An attempt to fix what some netflow v9 exporters do wrong.">fbCollectorManageUDPStreamByPort()</a> to prevent template confusion between streams.</p>
<h2><a class="anchor" id="NetFlow">
v9 Collector Usage</a></h2>
<p>libfixbuf can be used as a NetFlow v9 collector and convert NetFlow to IPFIX. Follow the steps above to create an fbListener. After creating the listener, retrieve the collector by calling <a class="el" href="public_8h.html#a7e64858b1a8766f7e2889b1de70fca97" title="fbListenerGetCollector">fbListenerGetCollector()</a> before calling <a class="el" href="public_8h.html#aa751f591a9ae4cd4a46c57f11798a592" title="fbCollectorSetNetflowV9Translator">fbCollectorSetNetflowV9Translator()</a>. Fixbuf can decode all NetFlow v9 information elements up to 346. Since fixbuf removes the SysUpTime from the NetFlow v9 Header, when fixbuf encounters elements 21 and 22 (which rely on the SysUpTime to determine flow start and end times) it will add IPFIX Element 160 (systemInitTimeMilliseconds) to the template and corresponding flow record. systemInitTimeMilliseconds is the Packet Export Time (found in the NetFlow v9 Header) converted to milliseconds minus the SysUpTime. Also, for arbitrary Cisco Elements (ID &gt; 346), fixbuf will convert the element ID to 9999 in order to decode the element properly. The exceptions are elements 33002 (NF_F_FW_EXT_EVENT) and 40005 (NF_F_FW_EVENT) which are often exported from Cisco's ASA device. These elements will be converted to their corresponding element id's in libfixbuf's default Information Model, 9997 and 9998 respectively. Similarly, the Cisco ASA will also export elements 40001, 40002, 40003, and 40004. These elements are substituted with the IPFIX elements 225, 226, 227, and 228 respectively.</p>
<p>libfixbuf differentiates Netflow v9 streams by IP and observation domain. If no activity is seen from a NetFlow v9 exporter within 30 minutes, the session and all the templates associated with it will be freed. It is best to set the template timeout period on the device to under 30 minutes.</p>
<p><a class="el" href="public_8h.html#a09cc8db0d961b61a5087c5b107b8c1eb" title="fbCollectorGetNetflowMissed">fbCollectorGetNetflowMissed()</a> can be used to retrieve the number of potential missed export packets. This is not the number of FLOW records that the collector has missed. NetFlow v9 increases sequence numbers by the number of export packets it has sent, NOT the number of flow records. An export packet may not contain any flow records. Fixbuf tries to account for any reboot of the device and not count large sequence number discrepancies in it's missed count.</p>
<h2><a class="anchor" id="Spread">
Collector Usage - Using the Spread Protocol</a></h2>
<p>Similar to reading from IPFIX Files, Create an fbInfoModel_t and an fbSession_t as above, though you should not define external templates in the new session for collection (instead requiring them to be sent from the group that you are subscribing to). Define an fbSpreadParams_t and set the session, groups to subscribe to, and Spread Daemon name.</p>
<p>Then create an fbCollector_t to connect and listen to the Spread Daemon using fbCollectorAllocSpread().</p>
<p>With an fbSession_t and fbcollector_t available, create a buffer for writing via <a class="el" href="public_8h.html#a71b2a64c7d212e9c3562388b95b993ab" title="Allocate a new buffer for collection.">fBufAllocForCollection()</a>. Set the internal template ID with <a class="el" href="public_8h.html#a28c6c56234351a793fd513b212bd31b8" title="Set the internal template on a buffer to the given template ID.">fBufSetInternalTemplate()</a>, and use <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a> to read records from IPFIX Messages published to the group your collector is subscribing to.</p>
<p>To view all the Spread Groups that were sent the incoming record, call fbCollectorGetSpreadReturnGroups() on the collector.</p>
<h2><a class="anchor" id="lists">
Lists in IPFIX</a></h2>
<h3><a class="anchor" id="general">
General Information</a></h3>
<p>Each of the list structures uses a nested list of data. The basic list nests a single information element, while the others use a nested template. The template used for nesting is part of the listed templates sent to the collector when the connection is made, or when the data transfer begins. There is no way to mark a template from this list as one that will be nested, or one that will be used as the highest level template. Each of the templates in the list are treated as equals.</p>
<p>The collector does not learn which template or information element is nested until the data arrives. This requires flexbility in the collectors to handle each of the possible results.</p>
<h4><a class="anchor" id="internalTemplates">
Internal Templates for Sub Templates</a></h4>
<p>The setting of the internal template has not changed with the addition of the list structures. The internal template is still used to perform the initial decoding of the data that arrives at the collector.</p>
<p>Basic lists are not transcoded in the same way as templates because they contain just one information element, thus having no order, so the data can just be parsed and copied to a buffer.</p>
<p>The question with decoding sub templates becomes, what do we use as an internal template for any sub templates that arrive? The answer is a new structure in fixbuf that pairs external and internal template IDs for use in decoding sub templates. The pairs are added to the session that is used for the connection, using <a class="el" href="public_8h.html#a1b142aa40a63aab16b297c77649f3d5c" title="Adds an external-internal template pair to the session.">fbSessionAddTemplatePair()</a>.</p>
<p>Because the external template IDs are only unique for that session, the collector must know the IDs of the templates that are collected in order to pair an internal template with the external template. As a result, callback functionality has been added to fixbuf to alert the user when a new external template has arrived. The function to be called is stored in the session structure, which manages the templates. The callback gives the user a pointer to the template structure which contains the information elements, allowing the application to determine the contents of the template. The template ID used for this template, along with the session pointer is enough for the application to successfully add template pairs to the session for sub template decoding.</p>
<p>If the application does not use the callback, or does not add any template pairs to the session, then fixbuf will transcode each of the sub templates as if the external and internal template were same. This causes all of the fields sent over the wire to be transcoded into the data buffer on the collecting side. The details of that template are passed up to the collector upon receipt of data so it knows how the data is structured in the buffer.</p>
<p>If the application adds any template pair to the list, then the list will be referenced for each transcode. Any external template the application wishes to process MUST have an entry in the list. There are 3 cases for entries in the list: 1. There is no entry for the given external template ID, so the entire sub template is ignored by the transcoder. The collector will be given a sub template list (or multi list entry) struct with the number of elements in the list set to 0, and the data pointer set to NULL. 2. The listing exists, and the external and internal template IDs are set to the same value. When decoding, the list of internal templates is queried to see if a template exists with the same ID as the external template. If not, the transcoder decodes each of the information elements, in the same order, into the buffer. This is a change as setting them equal to each other used to force a full decode. This change highlights the need for careful template ID management. 3. The listing exists, and the external and internal template IDs are different. This will transcode in the standard way external templates have been transcoded into internal templates, selecting the desired elements (listed in the internal template) from the data that arrived in the external template.</p>
<h4><a class="anchor" id="iterating">
Iterating Over the Lists</a></h4>
<p>There are four scenerios in which the user needs to iterate through the elements in a list, whether to fill in, or process the data: 1. Iterating over the repeated information element data in a basic list 2. Iterating over the decoded data elements in a sub template list 3. Iterating over the entries that make up a sub template multi list 4. Iterating over the docoded data elements in an entry of a sub template multi list The two iterating mechanisms are the same in each case: Each of the function names start with the structure being iterated over, e.g., fbBasicList, or fbSubTemplateMultiListEntry 1. Indexing The function used here is (structName)GetIndexed(dataPtr or entry)() It takes a pointer to the struct, and the index to be retrieved. Example usage: for(i = 0; myStructPtr = ...GetIndexedDataPtr(listPtr, i); i++) { process the data that myStructPtr points to. } The loop will end because when i is passed the bounds of the list the GetIndexedDataPtr() returns NULL.</p>
<p>2. Incrementing The function used here is (structName)GetNext(dataPtr or entry)() It takes a pointer to the struct, and a pointer to an element in the list. Pass in NULL at the beginning to get the first element back. Example usage: myStructPtr = NULL; while(myStructPtr = ...GetNextPtr(listPtr, myStructPtr)) { process the data that myStructPtr points to. } The loop will end because the function will return NULL when it gets passed the end of the list. A key part here is initializing myStructPtr to NULL at the beginning! </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ae180698bcf1673599ce689814af51078"></a><!-- doxytag: member="public.h::FB_CISCO_ASA_EVENT_ID" ref="ae180698bcf1673599ce689814af51078" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_CISCO_ASA_EVENT_ID&nbsp;&nbsp;&nbsp;9998</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Information Element ID for Cisco NSEL Element NF_F_FW_EVENT often exported by Cisco's ASA Device. </p>
<p>This must be converted to a different Information Element ID due to the reverse IE bit in IPFIX. Cisco uses IE ID 40005. <a href="http://www.cisco.com/en/US/docs/security/asa/asa82/netflow/netflow.html">http://www.cisco.com/en/US/docs/security/asa/asa82/netflow/netflow.html</a> </p>

</div>
</div>
<a class="anchor" id="a0f1037623125ccfc4f42a08377f61ee1"></a><!-- doxytag: member="public.h::FB_CISCO_ASA_EVENT_XTRA" ref="a0f1037623125ccfc4f42a08377f61ee1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_CISCO_ASA_EVENT_XTRA&nbsp;&nbsp;&nbsp;9997</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Information Element ID for Cisco NSEL Element NF_F_FW_EXT_EVENT often exported by Cisco's ASA Device. </p>
<p>This must be converted to a different Information Element ID due to the reverse IE bit in IPFIX. Cisco uses IE ID 33002 <a href="http://www.cisco.com/en/US/docs/security/asa/asa82/netflow/netflow.html">http://www.cisco.com/en/US/docs/security/asa/asa82/netflow/netflow.html</a> </p>

</div>
</div>
<a class="anchor" id="a4f6b39310e0db0215096369ffaf342e6"></a><!-- doxytag: member="public.h::FB_CONNSPEC_INIT" ref="a4f6b39310e0db0215096369ffaf342e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_CONNSPEC_INIT</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ <a class="code" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338a7e8c8d5180377a3e0c466dd421a5b541" title="Partially reliable datagram transport via SCTP.">FB_SCTP</a>, NULL, NULL,         \
                           NULL, NULL, NULL, NULL,      \
                           NULL, NULL }
</pre></div>
<p>Convenience macro defining a null static fbConnSpec_t. </p>

</div>
</div>
<a class="anchor" id="a2e0ffd43c861a9833b279557d687c57a"></a><!-- doxytag: member="public.h::FB_ERROR_BUFSZ" ref="a2e0ffd43c861a9833b279557d687c57a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_BUFSZ&nbsp;&nbsp;&nbsp;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A message was received larger than the collector buffer size. </p>
<p>Should never occur. This condition is checked at the transport layer in case future versions of fixbuf support dynamic buffer sizing. </p>

</div>
</div>
<a class="anchor" id="a16875886e559694c2a5d80cc1b9e00de"></a><!-- doxytag: member="public.h::FB_ERROR_DOMAIN" ref="a16875886e559694c2a5d80cc1b9e00de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_DOMAIN&nbsp;&nbsp;&nbsp;g_quark_from_string(&quot;fixbufError&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>All fixbuf errors are returned within the FB_ERROR_DOMAIN domain. </p>

</div>
</div>
<a class="anchor" id="a367b1a2c0af72830b0c9905b2db317cb"></a><!-- doxytag: member="public.h::FB_ERROR_EOF" ref="a367b1a2c0af72830b0c9905b2db317cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_EOF&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>End of IPFIX Message stream. </p>
<p>No more messages are available from the transport layer on read, either because the session has closed, or the file has been processed. </p>

</div>
</div>
<a class="anchor" id="a0259831c04ac6aeee7cb6c96d76b3d65"></a><!-- doxytag: member="public.h::FB_ERROR_EOM" ref="a0259831c04ac6aeee7cb6c96d76b3d65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_EOM&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>End of IPFIX message. </p>
<p>Either there are no more records present in the message on read, or the message MTU has been reached on write. </p>

</div>
</div>
<a class="anchor" id="af25725f494c04fdab230c546953bdda9"></a><!-- doxytag: member="public.h::FB_ERROR_IMPL" ref="af25725f494c04fdab230c546953bdda9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_IMPL&nbsp;&nbsp;&nbsp;6</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The requested feature is not yet implemented. </p>

</div>
</div>
<a class="anchor" id="ac34f5cab6ec1507f9626c1501b9b8d42"></a><!-- doxytag: member="public.h::FB_ERROR_IO" ref="ac34f5cab6ec1507f9626c1501b9b8d42" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_IO&nbsp;&nbsp;&nbsp;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An unspecified I/O error occured. </p>

</div>
</div>
<a class="anchor" id="aa225780afc0e4680caf26e0ec9ab2427"></a><!-- doxytag: member="public.h::FB_ERROR_IPFIX" ref="aa225780afc0e4680caf26e0ec9ab2427" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_IPFIX&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Illegal IPFIX mesaage content on read. </p>
<p>The input stream is malformed, or is not an IPFIX Message after all. </p>

</div>
</div>
<a class="anchor" id="a85d583572e660442b964f967d6b4e30c"></a><!-- doxytag: member="public.h::FB_ERROR_NETFLOWV9" ref="a85d583572e660442b964f967d6b4e30c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_NETFLOWV9&nbsp;&nbsp;&nbsp;12</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Illegal NetflowV9 content on a read. </p>
<p>Can't parse the Netflow header or the stream is not a NetflowV9 stream </p>

</div>
</div>
<a class="anchor" id="a11335d44d4833a94788908cc0e019c32"></a><!-- doxytag: member="public.h::FB_ERROR_NLREAD" ref="a11335d44d4833a94788908cc0e019c32" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_NLREAD&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>No data is available for reading from the transport layer. </p>
<p>Either a transport layer read was interrupted, or timed out. </p>

</div>
</div>
<a class="anchor" id="a6a865a476cfedc1bd762a815a919b3d6"></a><!-- doxytag: member="public.h::FB_ERROR_NLWRITE" ref="a6a865a476cfedc1bd762a815a919b3d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_NLWRITE&nbsp;&nbsp;&nbsp;9</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An attempt to write data to the transport layer failed due to closure of the remote end of the connection. </p>
<p>Currently only occurs with the TCP transport layer. </p>

</div>
</div>
<a class="anchor" id="af9fea2f3d2282f4130b0762bfdf4cdc8"></a><!-- doxytag: member="public.h::FB_ERROR_TMPL" ref="af9fea2f3d2282f4130b0762bfdf4cdc8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_ERROR_TMPL&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>No template was available for the given template ID. </p>

</div>
</div>
<a class="anchor" id="ad5904eae4a46ffa0d02fe24e25bf8f88"></a><!-- doxytag: member="public.h::FB_IE_F_ALIEN" ref="ad5904eae4a46ffa0d02fe24e25bf8f88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_F_ALIEN&nbsp;&nbsp;&nbsp;0x00000080</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Information element alien flag. </p>
<p>If set, IE is enterprise-specific and was recieved via an external template at a Collecting Process. It is therefore subject to semantic typing via options (not yet implemented). Do not set this flag on information elements added programmatically to an information model via <a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0" title="Add a single information element to an information model.">fbInfoModelAddElement()</a> or <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a>. </p>

</div>
</div>
<a class="anchor" id="a8999778f3785deb0579e458b87671832"></a><!-- doxytag: member="public.h::FB_IE_F_ENDIAN" ref="a8999778f3785deb0579e458b87671832" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_F_ENDIAN&nbsp;&nbsp;&nbsp;0x00000001</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Information element endian conversion flag. </p>
<p>If set, IE is an integer and will be endian-converted on transcode. </p>

</div>
</div>
<a class="anchor" id="a57b7a85944a72f6a16741191eb9458df"></a><!-- doxytag: member="public.h::FB_IE_F_NONE" ref="a57b7a85944a72f6a16741191eb9458df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_F_NONE&nbsp;&nbsp;&nbsp;0x00000000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default treatment flags value. </p>
<p>Provided for initializer convenience. Corresponds to octet-array semantics for a non-reversible, non-alien IE. </p>

</div>
</div>
<a class="anchor" id="af8e002cfbd82eff68afc556f9786c182"></a><!-- doxytag: member="public.h::FB_IE_F_REVERSIBLE" ref="af8e002cfbd82eff68afc556f9786c182" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_F_REVERSIBLE&nbsp;&nbsp;&nbsp;0x00000040</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Information element reversible flag. </p>
<p>If set for an information element with an enterprise number of 0 (an IETF/IANA IE), adding the information element via <a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0" title="Add a single information element to an information model.">fbInfoModelAddElement()</a> or <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a> will cause a second, reverse information element to be added to the model following the conventions in IETF Internet-Draft draft-ietf-ipfix-biflow-03. Note that the reverse PEN has not yet been assigned, so this implementation uses a provisional reverse IE as defined by the macro FB_IE_PEN_REVERSE. </p>

</div>
</div>
<a class="anchor" id="af98543cbda640dfca398c2d077382a36"></a><!-- doxytag: member="public.h::FB_IE_INIT" ref="af98543cbda640dfca398c2d077382a36" args="(_name_, _ent_, _num_, _len_, _flags_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_INIT</td>
          <td>(</td>
          <td class="paramtype">_name_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ent_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_num_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_len_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_flags_&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;{{(const struct <a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a>*)_name_}, 0, _ent_, _num_, _len_, _flags_}</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convenience macro for creating fbInfoElement_t static initializers. </p>
<p>Used for creating information element arrays suitable for passing to <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a>. </p>

</div>
</div>
<a class="anchor" id="a4e1799c19a4376b5e94a9f2c46af1af0"></a><!-- doxytag: member="public.h::FB_IE_PEN_REVERSE" ref="a4e1799c19a4376b5e94a9f2c46af1af0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_PEN_REVERSE&nbsp;&nbsp;&nbsp;29305</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Private enterprise number for reverse information elements (see draft-ietf-ipfix-biflow-03 section 6.1). </p>
<p>If an information element with FB_IE_F_REVERSIBLE and a zero enterprise number (i.e., an IANA-assigned information element) is added to a model, the reverse IE will be generated by setting the enterprise number to this constant. </p>

</div>
</div>
<a class="anchor" id="af2a306f4cc41ea9e8d7828cd6c8023fd"></a><!-- doxytag: member="public.h::FB_IE_REVERSE_STR" ref="af2a306f4cc41ea9e8d7828cd6c8023fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_REVERSE_STR&nbsp;&nbsp;&nbsp;&quot;reverse&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse information element name prefix. </p>
<p>This string is prepended to an information element name, and the first character after this string is capitalized, when generating a reverse information element. </p>

</div>
</div>
<a class="anchor" id="ac784ef024c2089ce88fe18db93cea70e"></a><!-- doxytag: member="public.h::FB_IE_REVERSE_STRLEN" ref="ac784ef024c2089ce88fe18db93cea70e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_REVERSE_STRLEN&nbsp;&nbsp;&nbsp;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Length of reverse information element name prefix. </p>

</div>
</div>
<a class="anchor" id="ac0892f774e630526db23f2d4090817c1"></a><!-- doxytag: member="public.h::FB_IE_VENDOR_BIT_REVERSE" ref="ac0892f774e630526db23f2d4090817c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FB_IE_VENDOR_BIT_REVERSE&nbsp;&nbsp;&nbsp;0x4000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse information element bit for vendor-specific information elements (see draft-ietf-ipfix-biflow-03 section 6.2). </p>
<p>If an information element with FB_IE_F_REVERSIBLE and a non-zero enterprise number (i.e., a vendor-specific information element) is added to a model, the reverse IE number will be generated by ORing this bit with the given forward information element number. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aa0f87164ee76983beadbf79299681f20"></a><!-- doxytag: member="public.h::fbAcceptCallback_fn" ref="aa0f87164ee76983beadbf79299681f20" args=")(fBuf_t *buf, fbListener_t *listener, struct sockaddr *sAddr, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef gboolean(* <a class="el" href="public_8h.html#aa0f87164ee76983beadbf79299681f20">fbAcceptCallback_fn</a>)(<a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *buf, <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, struct sockaddr *sAddr, GError **err)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the callback function to be called when a new connection to a listener has been received. </p>
<p>The memory pointed to by buf and listener will not be cleared so copies of that memory do not need to be done in this function, just copies of the pointers themselves will need to be retained. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>pointer to the new buffer created for the new collector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>pointer to the listener that received the connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sAddr</em>&nbsp;</td><td>sockaddr struct describing the connecting node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>error buffer containing error string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE is the callback succeeds, FALSE on error </dd></dl>

</div>
</div>
<a class="anchor" id="adbe40eb39792bfedc00d221c8c9f7a15"></a><!-- doxytag: member="public.h::fbCollector_t" ref="adbe40eb39792bfedc00d221c8c9f7a15" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbCollector_st <a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IPFIX Collecting Process endpoint. </p>
<p>Used to collect messages into an associated IPFIX Message Buffer from a remote Exporting Process, or from an IPFIX File. Use this with the fbListener_t structure to implement a full Collecting Process, including Transport Session setup. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="abbc3c1c84682e0e8d89280fbe828b392"></a><!-- doxytag: member="public.h::fbConnSpec_t" ref="abbc3c1c84682e0e8d89280fbe828b392" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_conn_spec__st.html">fbConnSpec_st</a>  <a class="el" href="structfb_conn_spec__st.html">fbConnSpec_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connection specifier. </p>
<p>Used to define a peer address for fbExporter_t, or a passive address for fbListener_t. </p>

</div>
</div>
<a class="anchor" id="a054d6ae24ecc9fbc2e38e683d8a5481a"></a><!-- doxytag: member="public.h::fbExporter_t" ref="a054d6ae24ecc9fbc2e38e683d8a5481a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbExporter_st <a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IPFIX Exporting Process endpoint. </p>
<p>Used to export messages from an associated IPFIX Message Buffer to a remote Collecting Process, or to an IPFIX File. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="a8e5e041c0ef22a30e1b916c6284cb180"></a><!-- doxytag: member="public.h::fbInfoElement_t" ref="a8e5e041c0ef22a30e1b916c6284cb180" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_info_element__st.html">fbInfoElement_st</a>  <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A single IPFIX Information Element definition. </p>
<p>An Information Element defines the type of data in each field of a record. This structure may be contained in an fbInfoModel_t, in which case the name field contians the information element name, or an an fbTemplate_t, in which case the canon field references the fbInfoElement_t contained within the Information Model. </p>

</div>
</div>
<a class="anchor" id="ab31a6d6f2d24c483d1dc3d7cc8f71009"></a><!-- doxytag: member="public.h::fbInfoElementSpec_t" ref="ab31a6d6f2d24c483d1dc3d7cc8f71009" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_st</a>  <a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A single IPFIX Information Element specification. </p>
<p>Used to name an information element for inclusion in a template by <a class="el" href="public_8h.html#acb8f6399ecdbbc6af8fbacedc4e49a6c" title="Append information elements described by a specifier array to a template.">fbTemplateAppendSpecArray()</a>. </p>

</div>
</div>
<a class="anchor" id="a7403b5635628fcc24eeb03b73c0b08bd"></a><!-- doxytag: member="public.h::fbInfoModel_t" ref="a7403b5635628fcc24eeb03b73c0b08bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbInfoModel_st <a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An IPFIX information model. </p>
<p>Contains information element definitions. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="a4265eb950b491c405d075f1510a5710e"></a><!-- doxytag: member="public.h::fbListener_t" ref="a4265eb950b491c405d075f1510a5710e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbListener_st <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IPFIX Collecting Process session listener. </p>
<p>Used to wait for connections from IPFIX Exporting Processes, and to manage open connections via a select(2)-based mechanism. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="a4bfbe8463a351cde3e2e62436721abda"></a><!-- doxytag: member="public.h::fbListenerAppFree_fn" ref="a4bfbe8463a351cde3e2e62436721abda" args=")(void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="public_8h.html#a4bfbe8463a351cde3e2e62436721abda">fbListenerAppFree_fn</a>)(void *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Application context free function type for fbListener_t. </p>
<p>If the Collector is in multi-session mode (see appinit fn), then the appfree function will be called if a session is timed out (does not receive a UDP message for more than 30 minutes.) Called during fbCollector_t cleanup. </p>

</div>
</div>
<a class="anchor" id="a1fb1a0bf576fb67a0f42143416dc205c"></a><!-- doxytag: member="public.h::fbListenerAppInit_fn" ref="a1fb1a0bf576fb67a0f42143416dc205c" args=")(fbListener_t *listener, void **ctx, int fd, struct sockaddr *peer, size_t peerlen, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef gboolean(* <a class="el" href="public_8h.html#a1fb1a0bf576fb67a0f42143416dc205c">fbListenerAppInit_fn</a>)(<a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *listener, void **ctx, int fd, struct sockaddr *peer, size_t peerlen, GError **err)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Application context initialization function type for fbListener_t. </p>
<p>This function is called after accept(2) for TCP or SCTP with the peer address in the peer argument. For UDP, it is called during fbListener_t initialization and the peer address will be NULL. If the Collector is in multi-session mode, the appinit function will be called when a new UDP connection occurs with the peer address, similiar to the TCP case. Use <a class="el" href="public_8h.html#a1b18e9e1ccb41a90189125042c952de9" title="Attempt to maintain backwards compatibility with UDP.">fbCollectorSetUDPMultiSession()</a> to turn on multi-session mode (off by default). The application may veto fbCollector_t creation by returning FALSE. In multi-session mode, if the connection is to be ignored, the application should set error code FB_ERROR_NLREAD on the err and return FALSE. If the application returns FALSE, fixbuf will maintain information about that peer, and will reject connections from that peer until shutdown or until that session times out. Fixbuf will return FB_ERROR_NLREAD for previously rejected sessions. The context (returned via out-parameter ctx) will be stored in the fbCollector_t, and is retrievable via a call to <a class="el" href="public_8h.html#ad9fa506279884348752111ff3bb52882" title="Retrieve the application context associated with a collector.">fbCollectorGetContext()</a>. If not in multi-session mode and using the appinit fn, the ctx will be associated with all UDP sessions. </p>

</div>
</div>
<a class="anchor" id="a5c72c26427ae0efc734862b95cb09ae9"></a><!-- doxytag: member="public.h::fbNewTemplateCallback_fn" ref="a5c72c26427ae0efc734862b95cb09ae9" args=")(fbSession_t *session, uint16_t tid, fbTemplate_t *tmpl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="public_8h.html#a5c72c26427ae0efc734862b95cb09ae9">fbNewTemplateCallback_fn</a>)(<a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *session, uint16_t tid, <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *tmpl)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The callback function to be called when the session receives a new external template from the connected node. </p>
<p>The point of this callback is to be able to assign an internal template to a received external template for subTemplates </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a pointer to the session that received the template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>the template ID for the template that was received </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>pointer to the template information of the received template </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NO return value </dd></dl>

</div>
</div>
<a class="anchor" id="a8441ccbdab7eaccc081dae0e3af32855"></a><!-- doxytag: member="public.h::fbSession_t" ref="a8441ccbdab7eaccc081dae0e3af32855" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fbSession_st <a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An IPFIX Transport Session state container. </p>
<p>Though Session creation and lifetime are managed by the fbCollector_t and fbExporter_t types, each fBuf_t buffer uses this type to store session state, including internal and external Templates and Message Sequence Number information. </p>

</div>
</div>
<a class="anchor" id="afb88011d092a7157d3632a6d660294d6"></a><!-- doxytag: member="public.h::fbSubTemplateList_t" ref="afb88011d092a7157d3632a6d660294d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_st</a>  <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Structure used to hold information of a sub template list. </p>
<p>This structure is filled in by the user in an exporter to tell fixbuf how to encode the data. This structure is filled in by the transcoder in a collector, feeding the useful information up to the user </p>

</div>
</div>
<a class="anchor" id="a21c182c97f40c7c8f213e8e090d9057a"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListEntry_t" ref="a21c182c97f40c7c8f213e8e090d9057a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_st</a>  <a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Entries contain the same type of information at SubTemplateLists: template ID and template pointers to describe the data the number of data elements and the data pointer and data length. </p>
<p>Sub template multi lists are inherently nested constructions. At a high level, they are a list of sub template lists. The first level is a list of fbSubTemplateMultiListEntry_t's, which each contain the information that describes the data contained in them. Initializing a fbSubTemplateMultiList_t with a semantic and number of elements returns memory that contains numElements blocks of memory containing fbSubTemplateMultiListEntry_t's. It is not ready to accept data. Each of the fbSubTemplateMultiListEntry_t's needed to be set up then data is copied into the entries. </p>

</div>
</div>
<a class="anchor" id="a1a98b02ac2e3547d96e839174270af99"></a><!-- doxytag: member="public.h::fbTemplate_t" ref="a1a98b02ac2e3547d96e839174270af99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_template__st.html">fbTemplate_st</a> <a class="el" href="structfb_template__st.html">fbTemplate_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An IPFIX Template or Options Template. </p>
<p>Templates define the structure of data records and options records within an IPFIX Message. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="a484fac3d07ebd24f2d165a74973be704"></a><!-- doxytag: member="public.h::fbTransport_t" ref="a484fac3d07ebd24f2d165a74973be704" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">fbTransport_en</a>  <a class="el" href="public_8h.html#a484fac3d07ebd24f2d165a74973be704">fbTransport_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transport protocol for connection specifier. </p>

</div>
</div>
<a class="anchor" id="ab1479ebe89aecd202bb628c33102129b"></a><!-- doxytag: member="public.h::fBuf_t" ref="ab1479ebe89aecd202bb628c33102129b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct fBuf_st <a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An IPFIX message buffer. </p>
<p>Used to encode and decode records from IPFIX Messages. The internals of this structure are private to libfixbuf. </p>

</div>
</div>
<a class="anchor" id="ae4c56b8891012ac69488b0a9558aaf9e"></a><!-- doxytag: member="public.h::fbVarfield_t" ref="ae4c56b8891012ac69488b0a9558aaf9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfb_varfield__st.html">fbVarfield_st</a>  <a class="el" href="structfb_varfield__st.html">fbVarfield_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A variable-length field value. </p>
<p>Variable-length information element content is represented by an fbVarfield_t on the internal side of the transcoder; that is, variable length fields in an IPFIX Message must be represented by this structure within the application record. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338"></a><!-- doxytag: member="public.h::fbTransport_en" ref="a42b75e3dc15f6c6ebb447598eb7d9338" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="public_8h.html#a42b75e3dc15f6c6ebb447598eb7d9338">fbTransport_en</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transport protocol for connection specifier. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a7e8c8d5180377a3e0c466dd421a5b541"></a><!-- doxytag: member="FB_SCTP" ref="a42b75e3dc15f6c6ebb447598eb7d9338a7e8c8d5180377a3e0c466dd421a5b541" args="" -->FB_SCTP</em>&nbsp;</td><td>
<p>Partially reliable datagram transport via SCTP. </p>
<p>Only available if fixbuf was built with SCTP support. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a3d0d039b439e58056f0318fc8d40f69e"></a><!-- doxytag: member="FB_TCP" ref="a42b75e3dc15f6c6ebb447598eb7d9338a3d0d039b439e58056f0318fc8d40f69e" args="" -->FB_TCP</em>&nbsp;</td><td>
<p>Reliable stream transport via TCP. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a99b2804a276e4d9bb12df356a58249e2"></a><!-- doxytag: member="FB_UDP" ref="a42b75e3dc15f6c6ebb447598eb7d9338a99b2804a276e4d9bb12df356a58249e2" args="" -->FB_UDP</em>&nbsp;</td><td>
<p>Unreliable datagram transport via UDP. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a0e089a579ef744ed527b20018e0d2fa9"></a><!-- doxytag: member="FB_DTLS_SCTP" ref="a42b75e3dc15f6c6ebb447598eb7d9338a0e089a579ef744ed527b20018e0d2fa9" args="" -->FB_DTLS_SCTP</em>&nbsp;</td><td>
<p>Secure, partially reliable datagram transport via DTLS over SCTP. </p>
<p>Only available if fixbuf was built with OpenSSL support. Requires an OpenSSL implementation of DLTS over SCTP, not yet available. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a26085cf8945b1127fe9aa2671544cac8"></a><!-- doxytag: member="FB_TLS_TCP" ref="a42b75e3dc15f6c6ebb447598eb7d9338a26085cf8945b1127fe9aa2671544cac8" args="" -->FB_TLS_TCP</em>&nbsp;</td><td>
<p>Secure, reliable stream transport via TLS over TCP. </p>
<p>Only available if fixbuf was built with OpenSSL support. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a42b75e3dc15f6c6ebb447598eb7d9338a1adfe2d456296749abdd84cc5dcbf997"></a><!-- doxytag: member="FB_DTLS_UDP" ref="a42b75e3dc15f6c6ebb447598eb7d9338a1adfe2d456296749abdd84cc5dcbf997" args="" -->FB_DTLS_UDP</em>&nbsp;</td><td>
<p>Secure, unreliable datagram transport via DTLS over UDP. </p>
<p>Only available if fixbuf was built with OpenSSL support. Requires OpenSSL 0.9.8 or later with DTLS support. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4d84288b9feaa32be492448b794a3697"></a><!-- doxytag: member="public.h::fbBasicListAddNewElements" ref="a4d84288b9feaa32be492448b794a3697" args="(fbBasicList_t *basicList, uint16_t numNewElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListAddNewElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>numNewElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates an additional elememnt into the basic list must be called after calling BasicListInit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicList</em>&nbsp;</td><td>pointer to the basic list to add elements to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numNewElements</em>&nbsp;</td><td>number of elements to add to the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the newly allocated element(s) </dd></dl>

</div>
</div>
<a class="anchor" id="a682b8bb11a27e75655696a565e588415"></a><!-- doxytag: member="public.h::fbBasicListAlloc" ref="a682b8bb11a27e75655696a565e588415" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a>* fbBasicListAlloc </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a Basic List Structure </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer a to the allocated basic list in memory </dd></dl>

</div>
</div>
<a class="anchor" id="ae2da02e486b6f9731f33d059cc5d6eca"></a><!-- doxytag: member="public.h::fbBasicListClear" ref="ae2da02e486b6f9731f33d059cc5d6eca" args="(fbBasicList_t *basicListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the parameters of the basic list and free the data buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>pointer to the basic list to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a8d17288918fee8fddd4c1b37fda3d691"></a><!-- doxytag: member="public.h::fbBasicListClearWithoutFree" ref="a8d17288918fee8fddd4c1b37fda3d691" args="(fbBasicList_t *basicList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListClearWithoutFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicList</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the parameters of the basic list, but do not free the buffer. </p>
<p>This should get used when the user provides their own buffer </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicList</em>&nbsp;</td><td>pointer to the basic list to clear without freeing </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a86efdc19c5c10383737e0de89c97b950"></a><!-- doxytag: member="public.h::fbBasicListCollectorInit" ref="a86efdc19c5c10383737e0de89c97b950" args="(fbBasicList_t *basicListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListCollectorInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This initializes a basic list structure for collection. </p>
<p>The key part of this function is it sets the dataPtr to NULL. If your basic list is declared as a pointer, then allocated using something like g_slice_alloc0 which sets it all to zero, you do not need to call this function. But if your basic list struct isn't a pointer, there dataPtr parameter will be set to garbage, which will break other fixbuf calls, so this function is required</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>pointer to the basic list to be initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="aef3712961929af50bc0900c30cbba773"></a><!-- doxytag: member="public.h::fbBasicListFree" ref="aef3712961929af50bc0900c30cbba773" args="(fbBasicList_t *basicListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the basic list, then free the basic list pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>pointer to the basic list to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a573bcfbfc4697838625af06884466e17"></a><!-- doxytag: member="public.h::fbBasicListGetDataPtr" ref="a573bcfbfc4697838625af06884466e17" args="(fbBasicList_t *basicListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListGetDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>pointer to the basic list to get the data pointer from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the data held by the basic list </dd></dl>

</div>
</div>
<a class="anchor" id="acdd859fd4bc3dc5974b321f0eee2e720"></a><!-- doxytag: member="public.h::fbBasicListGetIndexedDataPtr" ref="acdd859fd4bc3dc5974b321f0eee2e720" args="(fbBasicList_t *basicListPtr, uint16_t bl_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListGetIndexedDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>bl_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function retrieves the index'th element in the list index is 0-based. </p>
<p>Goes from 0 - (numElements-1) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>pointer to the basic list to retrieve the dataPtr </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bl_index</em>&nbsp;</td><td>the index of the element to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the data in the index'th slot in the list, NULL if the index is past the bounds of the list </dd></dl>

</div>
</div>
<a class="anchor" id="aa7be05a5a0f8e3b16c6ac3bf1f38a982"></a><!-- doxytag: member="public.h::fbBasicListGetInfoElement" ref="aa7be05a5a0f8e3b16c6ac3bf1f38a982" args="(fbBasicList_t *basicListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a>* fbBasicListGetInfoElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function returns a pointer to the information element used in the list it is mainly used in collectors to retrieve information. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>pointer to the basic list to get the infoElement from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the information element from the list </dd></dl>

</div>
</div>
<a class="anchor" id="aa5cd86fbb92c002a5a29b466c759393e"></a><!-- doxytag: member="public.h::fbBasicListGetNextPtr" ref="aa5cd86fbb92c002a5a29b466c759393e" args="(fbBasicList_t *basicListPtr, void *currentPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListGetNextPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>currentPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function returns the next element in the list based on the currentPtr. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>pointer to the basic list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentPtr</em>&nbsp;</td><td>pointer to the current element being used. Set to NULL to retrieve the first element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the next data slot, based on the current pointer. NULL if the new pointer is passed the end of the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="ab246e008d0cfe758ae98c3ac1d0342d1"></a><!-- doxytag: member="public.h::fbBasicListGetSemantic" ref="ab246e008d0cfe758ae98c3ac1d0342d1" args="(fbBasicList_t *basicListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fbBasicListGetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get Semantic field for Basic List presumably used in collectors after decoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>pointer to the basic list to retrieve the semantic from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the 8-bit semantic value describing the basic list </dd></dl>

</div>
</div>
<a class="anchor" id="a97a0558ba604ec339fc908594cdfa74f"></a><!-- doxytag: member="public.h::fbBasicListInit" ref="a97a0558ba604ec339fc908594cdfa74f" args="(fbBasicList_t *basicListPtr, uint8_t semantic, const fbInfoElement_t *infoElement, uint16_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *&nbsp;</td>
          <td class="paramname"> <em>infoElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the basic list structure based on the parameters. </p>
<p>This function allocates a buffer large enough to hold num elements amount of the infoElements.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>a pointer to the basic list structure to fill </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>semantic</em>&nbsp;</td><td>the semantic value to be used in the basic list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>infoElement</em>&nbsp;</td><td>a pointer to the info element to be used in the list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the memory where the list data is to be written </dd></dl>

</div>
</div>
<a class="anchor" id="ac422bc91621366c71eb467ec4181d360"></a><!-- doxytag: member="public.h::fbBasicListInitWithOwnBuffer" ref="ac422bc91621366c71eb467ec4181d360" args="(fbBasicList_t *basicListPtr, uint8_t semantic, const fbInfoElement_t *infoElement, uint16_t numElements, uint16_t dataLength, uint8_t *dataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListInitWithOwnBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *&nbsp;</td>
          <td class="paramname"> <em>infoElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>dataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>use this function to initialize the basic list, but it gets the pointer to a buffer and its length allocated independently from these functions This will generally be used by a collector that does not want to free and allocate new buffers for each incoming message </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>a pointer to the basic list structure to fill </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>semantic</em>&nbsp;</td><td>the semantic value to be used in the basic list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>infoElement</em>&nbsp;</td><td>a pointer to the info element to be used in the list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements in the list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dataLength</em>&nbsp;</td><td>length of the buffer passed to the function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dataPtr</em>&nbsp;</td><td>pointer to the buffer previously allocated for the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the beginning of the buffer on success, NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a2051991d465d885437c30e886bd86c3c"></a><!-- doxytag: member="public.h::fbBasicListRealloc" ref="a2051991d465d885437c30e886bd86c3c" args="(fbBasicList_t *basicList, uint16_t newNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbBasicListRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>newNumElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the current data pointer, allocating a new buffer to accomodate the new number of elements. </p>
<p>The remaining parameters are unchanged. If the number of elements hasn't changed the original buffer is used and its pointer is returned </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicList</em>&nbsp;</td><td>pointer to the basic list to realloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newNumElements</em>&nbsp;</td><td>new number of elements to allocate for the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the data pointer for the list after realloc </dd></dl>

</div>
</div>
<a class="anchor" id="a4fcc3e9eed3d8ba2178df3212d7e77f3"></a><!-- doxytag: member="public.h::fbBasicListSetSemantic" ref="a4fcc3e9eed3d8ba2178df3212d7e77f3" args="(fbBasicList_t *basicListPtr, uint8_t semantic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbBasicListSetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_basic_list__st.html">fbBasicList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>basicListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>semantic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the semantic for describing a basic list generally used in exporters before decoding. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>basicListPtr</em>&nbsp;</td><td>pointer to the basic list to set the semantic </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>semantic</em>&nbsp;</td><td>value to set the semantic field to </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a7549b8dcc9e44f02187708cfb36d14bc"></a><!-- doxytag: member="public.h::fbCollectorAllocFile" ref="a7549b8dcc9e44f02187708cfb36d14bc" args="(void *ctx, const char *path, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a>* fbCollectorAllocFile </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a collecting process endpoint for a named file. </p>
<p>The underlying file will be opened immediately.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>application context; for application use, retrievable by fbCollectorGetContext </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>path of file to read, or "-" to read standard input. Used to get fp, user creates and frees. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a collecting process endpoint, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a9891f65a4f6d838152b92c7afe97cc8d"></a><!-- doxytag: member="public.h::fbCollectorAllocFP" ref="a9891f65a4f6d838152b92c7afe97cc8d" args="(void *ctx, FILE *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a>* fbCollectorAllocFP </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a collecting process endpoint for an open file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctx</em>&nbsp;</td><td>application context; for application use, retrievable by fbCollectorGetContext </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>file pointer to file to read. Created and freed by user. Must be kept around for the life of the collector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a collecting process endpoint. </dd></dl>

</div>
</div>
<a class="anchor" id="a52d8b5f0c77c81fb9c67e3509418d724"></a><!-- doxytag: member="public.h::fbCollectorClearTranslator" ref="a52d8b5f0c77c81fb9c67e3509418d724" args="(fbCollector_t *collector, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbCollectorClearTranslator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fbCollectorClearTranslator </p>
<p>this removes an input translator from a given collector such that it will operate on IPFIX protocol again</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>the collector on which to remove the translator</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>when an error occurs, a Glib GError structure is set with an error description</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aef460934e9c8a4fe3530cf06f66ea3cb"></a><!-- doxytag: member="public.h::fbCollectorClose" ref="aef460934e9c8a4fe3530cf06f66ea3cb" args="(fbCollector_t *collector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbCollectorClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close the file or socket underlying a collecting process endpoint. </p>
<p>No effect on open file endpoints. If the collector is attached to a buffer managed by a listener, the buffer will be removed from the listener (that is, it will not be returned by subsequent <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a> calls).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>a collecting process endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9fa506279884348752111ff3bb52882"></a><!-- doxytag: member="public.h::fbCollectorGetContext" ref="ad9fa506279884348752111ff3bb52882" args="(fbCollector_t *collector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbCollectorGetContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the application context associated with a collector. </p>
<p>This context is taken from the ctx argument of <a class="el" href="public_8h.html#a7549b8dcc9e44f02187708cfb36d14bc" title="Allocate a collecting process endpoint for a named file.">fbCollectorAllocFile()</a> or <a class="el" href="public_8h.html#a9891f65a4f6d838152b92c7afe97cc8d" title="Allocate a collecting process endpoint for an open file.">fbCollectorAllocFP()</a>, or passed out via the ctx argument to the appinit function argument to <a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048" title="Allocate a listener.">fbListenerAlloc()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>a collecting process endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the application context </dd></dl>

</div>
</div>
<a class="anchor" id="a09cc8db0d961b61a5087c5b107b8c1eb"></a><!-- doxytag: member="public.h::fbCollectorGetNetflowMissed" ref="a09cc8db0d961b61a5087c5b107b8c1eb" args="(fbCollector_t *collector, struct sockaddr *peer, size_t peerlen, uint32_t obdomain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbCollectorGetNetflowMissed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>peerlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>obdomain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fbCollectorGetNetflowMissed </p>
<p>Returns the number of potential missed export packets of the Netflow v9 session that is currently set on the collector (the session is set on the collector when an export packet is received) if peer is NULL. If peer is set, this will look up the session for that peer/obdomain pair and return the missed export packets associated with that peer and obdomain. If peer/obdomain pair doesn't exist, this function returns 0. This can't return the number of missed flow records since Netflow v9 increases sequence numbers by the number of export packets it has sent, NOT the number of flow records (like IPFIX and netflow v5 does).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>peer</em>&nbsp;</td><td>[OPTIONAL] peer address of NetFlow v9 exporter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>peerlen</em>&nbsp;</td><td>size of peer object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>obdomain</em>&nbsp;</td><td>observation domain of NetFlow v9 exporter </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of missed packets since beginning of session </dd></dl>

</div>
</div>
<a class="anchor" id="a68260b0fb1b7947f6a76152a7c4cb6c1"></a><!-- doxytag: member="public.h::fbCollectorGetObservationDomain" ref="a68260b0fb1b7947f6a76152a7c4cb6c1" args="(fbCollector_t *collector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbCollectorGetObservationDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the observation domain of the node connected to the collector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85c920e8f0a74ca9ea1d4a40386d673f"></a><!-- doxytag: member="public.h::fbCollectorGetPeer" ref="a85c920e8f0a74ca9ea1d4a40386d673f" args="(fbCollector_t *collector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct sockaddr* fbCollectorGetPeer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves information about the node connected to this collector. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>pointer to the collector to get peer information from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to sockaddr structure containing IP information of peer </dd></dl>

</div>
</div>
<a class="anchor" id="a2efc61d324cb411b9a4c32acff0bc72c"></a><!-- doxytag: member="public.h::fbCollectorManageUDPStreamByPort" ref="a2efc61d324cb411b9a4c32acff0bc72c" args="(fbCollector_t *collector, gboolean manage_port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbCollectorManageUDPStreamByPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&nbsp;</td>
          <td class="paramname"> <em>manage_port</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An attempt to fix what some netflow v9 exporters do wrong. </p>
<p>Netflow v9 rfc 3954 states that collectors should use a combination of peer IP address and observation domain to manage netflow streams. However, some devices send two separate streams on the same IP, obdomain, and the only way to differentiate is by using peer port. Turning this flag on will prevent fixbuf from zeroing out the port before comparing sockaddr structs and makes fixbuf manage streams by ip, port, and obdomain.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>pointer to collector associated with listener. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>manage_port</em>&nbsp;</td><td>TRUE if fixbuf should manage UDP streams by port, FALSE by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac39b5a9a1eb9e8c8feaa9922cf73b300"></a><!-- doxytag: member="public.h::fbCollectorSetAcceptOnly" ref="ac39b5a9a1eb9e8c8feaa9922cf73b300" args="(fbCollector_t *collector, struct sockaddr *address, size_t address_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbCollectorSetAcceptOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>address_length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the collector to only receive from the given IP address over UDP. </p>
<p>The port will be ignored. Use <a class="el" href="public_8h.html#a7e64858b1a8766f7e2889b1de70fca97" title="fbListenerGetCollector">fbListenerGetCollector()</a> to get the pointer to the collector after calling <a class="el" href="public_8h.html#a68a2e34a62fbfe7fe37dffa8b6b05048" title="Allocate a listener.">fbListenerAlloc()</a>. ONLY valid for UDP. Set the address family in address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>pointer to collector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>pointer to sockaddr struct with IP address and family. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>address_length</em>&nbsp;</td><td>address length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa751f591a9ae4cd4a46c57f11798a592"></a><!-- doxytag: member="public.h::fbCollectorSetNetflowV9Translator" ref="aa751f591a9ae4cd4a46c57f11798a592" args="(fbCollector_t *collector, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbCollectorSetNetflowV9Translator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fbCollectorSetNetflowV9Translator </p>
<p>this sets the collector input translator to convert NetFlowV9 into IPFIX for the given collector</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>pointer to the collector state to perform Netflow V9 conversion on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>GError structure that holds the error message if an error occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on error </dd></dl>

</div>
</div>
<a class="anchor" id="a1b18e9e1ccb41a90189125042c952de9"></a><!-- doxytag: member="public.h::fbCollectorSetUDPMultiSession" ref="a1b18e9e1ccb41a90189125042c952de9" args="(fbCollector_t *collector, gboolean multi_session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbCollectorSetUDPMultiSession </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&nbsp;</td>
          <td class="paramname"> <em>multi_session</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempt to maintain backwards compatibility with UDP. </p>
<p>As of version 1.2, fixbuf calls the appinit functions when a new UDP connection occurs, as opposed to calling it during fbListenerAlloc. To maintain compatibility, with old applications, fixbuf will still call appinit in fbListenerAlloc with a null peer address. If UDP multi session is turned on, it will ALSO call appinit() when a new UDP connection occurs. Likewise with appfree(). Call <a class="el" href="public_8h.html#a7e64858b1a8766f7e2889b1de70fca97" title="fbListenerGetCollector">fbListenerGetCollector()</a> to obtain collector.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>pointer to collector associated with listener. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>multi_session</em>&nbsp;</td><td>TRUE if multi-session enabled, FALSE by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b159cd95821b4382a04543f18faa279"></a><!-- doxytag: member="public.h::fbExporterAllocFile" ref="a8b159cd95821b4382a04543f18faa279" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a>* fbExporterAllocFile </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate an exporting process endpoint for a named file. </p>
<p>The underlying file will not be opened until the first message is emitted from the buffer associated with the exporter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>pathname of the IPFIX File to write, or "-" to open standard output. Path is duplicated and handled. Original pointer is up to the user. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new exporting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a4055c4e29d7358629373e2be2a89a4dd"></a><!-- doxytag: member="public.h::fbExporterAllocFP" ref="a4055c4e29d7358629373e2be2a89a4dd" args="(FILE *fp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a>* fbExporterAllocFP </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate an exporting process endpoint for an opened ANSI C file pointer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fp</em>&nbsp;</td><td>open file pointer to write to. File pointer is created and freed outside of the Exporter functions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new exporting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a56ccd30ae0534e838107d39769b8f9f9"></a><!-- doxytag: member="public.h::fbExporterAllocNet" ref="a56ccd30ae0534e838107d39769b8f9f9" args="(fbConnSpec_t *spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a>* fbExporterAllocNet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_conn_spec__st.html">fbConnSpec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate an exporting process endpoint for a network connection. </p>
<p>The remote collecting process is specified by the given connection specifier. The underlying socket connection will not be opened until the first message is emitted from the buffer associated with the exporter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>remote endpoint connection specifier. A copy is made for the exporter, it is freed later. User is responsible for original spec pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new exporting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a809156340bdb9a1003ad57114eef5e0b"></a><!-- doxytag: member="public.h::fbExporterAutoStream" ref="a809156340bdb9a1003ad57114eef5e0b" args="(fbExporter_t *exporter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbExporterAutoStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exporter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable automatic SCTP stream selection for the next message exported. </p>
<p>Automatic stream selection is the default; use this call to re-enable it on a given exporter after using <a class="el" href="public_8h.html#a8d7419bcb555dba21cba184f7ce50086" title="Set the SCTP stream for the next message exported.">fbExporterSetStream()</a>. With automatic stream selection, the minimal behavior specified in the original IPFIX protocol (RFC xxxx) is used: all templates and options templates are exported on stream 0, and all data is exported on stream 1. This call is a no-op for non-SCTP exporters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exporter</em>&nbsp;</td><td>an exporting process endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac91f3ef3a469b8ec03eb195e70dbc16f"></a><!-- doxytag: member="public.h::fbExporterClose" ref="ac91f3ef3a469b8ec03eb195e70dbc16f" args="(fbExporter_t *exporter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbExporterClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exporter</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Force the file or socket underlying an exporting process endpoint to close. </p>
<p>No effect on open file endpoints. The file or socket may be reopened on a subsequent message emission from the associated buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exporter</em>&nbsp;</td><td>an exporting process endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d7419bcb555dba21cba184f7ce50086"></a><!-- doxytag: member="public.h::fbExporterSetStream" ref="a8d7419bcb555dba21cba184f7ce50086" args="(fbExporter_t *exporter, int sctp_stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbExporterSetStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exporter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sctp_stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the SCTP stream for the next message exported. </p>
<p>To change the SCTP stream used for export, first emit any message in the exporter's associated buffer with fbufEmit(), then use this call to set the stream for the next message. This call cancels automatic stream selection, use <a class="el" href="public_8h.html#a809156340bdb9a1003ad57114eef5e0b" title="Enable automatic SCTP stream selection for the next message exported.">fbExporterAutoStream()</a> to re-enable it. This call is a no-op for non-SCTP exporters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exporter</em>&nbsp;</td><td>an exporting process endpoint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sctp_stream</em>&nbsp;</td><td>SCTP stream to use for next message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae06a524366afa6827d7e5abb1c33c0d0"></a><!-- doxytag: member="public.h::fbInfoModelAddElement" ref="ae06a524366afa6827d7e5abb1c33c0d0" args="(fbInfoModel_t *model, fbInfoElement_t *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbInfoModelAddElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&nbsp;</td>
          <td class="paramname"> <em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a single information element to an information model. </p>
<p>The information element is assumed to be in "canonical" form; that is, its ref.name field should contain the information element name. The information element and its name are copied into the model; the caller may free or reuse its storage after this call.</p>
<p>See <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a> for a more convenient method of statically adding information elements to information models.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>model</em>&nbsp;</td><td>An information model </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ie</em>&nbsp;</td><td>Pointer to an information element to copy into the model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a202bfa2340263229893a38de18670179"></a><!-- doxytag: member="public.h::fbInfoModelAddElementArray" ref="a202bfa2340263229893a38de18670179" args="(fbInfoModel_t *model, fbInfoElement_t *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbInfoModelAddElementArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&nbsp;</td>
          <td class="paramname"> <em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add multiple information elements in an array to an information model. </p>
<p>The information elements are assumed to be in "canonical" form; that is, their ref.name fields should contain the information element name. Each information element and its name are copied into the model; the caller may free or reuse its storage after this call.</p>
<p>The ie parameter points to the first information element in an array, usually statically initialized with an array of FB_IE_INIT macros followed by an FB_IE_NULL macro. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>model</em>&nbsp;</td><td>An information model </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ie</em>&nbsp;</td><td>Pointer to an IE array to copy into the model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a390f707c7decf65060f31c0dba6c2a97"></a><!-- doxytag: member="public.h::fbInfoModelAlloc" ref="a390f707c7decf65060f31c0dba6c2a97" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a>* fbInfoModelAlloc </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a new information model. </p>
<p>The information model will contain all the default information elements in the IANA-managed number space, and may be extended via <a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0" title="Add a single information element to an information model.">fbInfoModelAddElement()</a> and <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Add multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a>.</p>
<p>An Information Model is required to create Templates and Sessions. Each application should have only one Information Model.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new Information Model </dd></dl>

</div>
</div>
<a class="anchor" id="a860639c9f5bdf973a8c303aa9f513454"></a><!-- doxytag: member="public.h::fbInfoModelFree" ref="a860639c9f5bdf973a8c303aa9f513454" args="(fbInfoModel_t *model)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbInfoModelFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&nbsp;</td>
          <td class="paramname"> <em>model</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free an information model. </p>
<p>Must not be called until all sessions and templates depending on the information model have also been freed; i.e., at application cleanup time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>model</em>&nbsp;</td><td>An information model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a507dc0fe44ee38bab3fb2c29917d5d08"></a><!-- doxytag: member="public.h::fbInfoModelGetElementByID" ref="a507dc0fe44ee38bab3fb2c29917d5d08" args="(fbInfoModel_t *model, uint16_t id, uint32_t ent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a>* fbInfoModelGetElementByID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&nbsp;</td>
          <td class="paramname"> <em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>ent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pointer to the canonical information element within an information model given the information element ID and enterprise ID. </p>
<p>The returned information element is owned by the information model and must not be modified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>model</em>&nbsp;</td><td>An information model </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>An information element id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ent</em>&nbsp;</td><td>An enterprise id </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The named information element within the model, or NULL if no such element exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dc8b2e255bc36ca22abbb811bf85c20"></a><!-- doxytag: member="public.h::fbInfoModelGetElementByName" ref="a5dc8b2e255bc36ca22abbb811bf85c20" args="(fbInfoModel_t *model, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a>* fbInfoModelGetElementByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&nbsp;</td>
          <td class="paramname"> <em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pointer to the canonical information element within an information model given the information element name. </p>
<p>The returned information element is owned by the information model and must not be modified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>model</em>&nbsp;</td><td>An information model </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the information element to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The named information element within the model, or NULL if no such element exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a68a2e34a62fbfe7fe37dffa8b6b05048"></a><!-- doxytag: member="public.h::fbListenerAlloc" ref="a68a2e34a62fbfe7fe37dffa8b6b05048" args="(fbConnSpec_t *spec, fbSession_t *session, fbListenerAppInit_fn appinit, fbListenerAppFree_fn appfree, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a>* fbListenerAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_conn_spec__st.html">fbConnSpec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a1fb1a0bf576fb67a0f42143416dc205c">fbListenerAppInit_fn</a>&nbsp;</td>
          <td class="paramname"> <em>appinit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4bfbe8463a351cde3e2e62436721abda">fbListenerAppFree_fn</a>&nbsp;</td>
          <td class="paramname"> <em>appfree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a listener. </p>
<p>The listener will listen on a specified local endpoint, and create a new collecting process endpoint and collection buffer for each incoming connection. Each new buffer will be associated with a clone of a given session state container.</p>
<p>The application may associate context with each created collecting process endpoint, or veto a connection attempt, via a function colled on each connection attempt passed in via the appinit parameter. If this function will create application context, provide a function via the appfree parameter which will free it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>local endpoint connection specifier. A copy is made of this, which is freed by listener. Original pointer freeing is up to the user. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>session state container to clone for each collection buffer created by the listener. Not freed by listener. Must be kept alive while listener exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>appinit</em>&nbsp;</td><td>application connection initiation function. Called on each collection attempt; vetoes connection attempts and creates application context. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>appfree</em>&nbsp;</td><td>application context free function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new listener, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aceb413ad5afd11a0437b583f922eb70a"></a><!-- doxytag: member="public.h::fbListenerFree" ref="aceb413ad5afd11a0437b583f922eb70a" args="(fbListener_t *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbListenerFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a listener. </p>
<p>Stops listening on the local endpoint, and frees any open buffers still managed by the listener.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>a listener </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e64858b1a8766f7e2889b1de70fca97"></a><!-- doxytag: member="public.h::fbListenerGetCollector" ref="a7e64858b1a8766f7e2889b1de70fca97" args="(fbListener_t *listener, fbCollector_t **collector, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbListenerGetCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> **&nbsp;</td>
          <td class="paramname"> <em>collector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>fbListenerGetCollector </p>
<p>If a collector is associated with the listener class, this will return a handle to the collector state structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>handle to the listener state </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>pointer to a collector state pointer, set on return if there is no error</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>a GError structure holding an error message on error</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE on error, check err, TRUE on success </dd></dl>

</div>
</div>
<a class="anchor" id="a5b5716c8fe63a2f982e32a98eed0e38f"></a><!-- doxytag: member="public.h::fbListenerGroupAddListener" ref="a5b5716c8fe63a2f982e32a98eed0e38f" args="(fbListenerGroup_t *group, const fbListener_t *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbListenerGroupAddListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a previously allocated listener to the previously allocated group. </p>
<p>The listener is placed at the head of the list</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>pointer to the allocated group to add the listener to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>pointer to the listener structure to add to the group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 upon success. "1" if entry couldn't be allocated "2" if either of the incoming pointers are NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a68c450b3579f5a1fa3c862a647eaa704"></a><!-- doxytag: member="public.h::fbListenerGroupAlloc" ref="a68c450b3579f5a1fa3c862a647eaa704" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a>* fbListenerGroupAlloc </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and returns a fbListenerGroup with no entries. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the created fbListenerGroup_t, or NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="acb9f0add5b127eb4f68270f56b65bc97"></a><!-- doxytag: member="public.h::fbListenerGroupDeleteListener" ref="acb9f0add5b127eb4f68270f56b65bc97" args="(fbListenerGroup_t *group, const fbListener_t *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbListenerGroupDeleteListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the listener from the group. </p>
<p>IT DOES NOT FREE THE LISTENER OR THE GROUP</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>pointer to the group to remove from the listener from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>pointer to the listener to remove from the group </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, and "1" if the listener is not found "2" if either of the pointers are NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a10d092063e0986f7fab4444fa0f65822"></a><!-- doxytag: member="public.h::fbListenerGroupWait" ref="a10d092063e0986f7fab4444fa0f65822" args="(fbListenerGroup_t *group, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_listener_group_result__st.html">fbListenerGroupResult_t</a>* fbListenerGroupWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Similar to fbListenerWait, except that is looks for connections for multiple listeners. </p>
<p>It takes a previously allocated and filled listener group. It returns a pointer to the head of a list of listenerGroupResults. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>pointer to the group of listeners to wait on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>error string structure seen throughout fixbuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the head of the listener group result list NULL on error, and sets the error string </dd></dl>

</div>
</div>
<a class="anchor" id="a1357c6b501f4b1823051e3d4a9f90af7"></a><!-- doxytag: member="public.h::fbListenerGroupWaitAcceptCallback" ref="a1357c6b501f4b1823051e3d4a9f90af7" args="(fbListenerGroup_t *group, fbAcceptCallback_fn callback, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbListenerGroupWaitAcceptCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_listener_group__st.html">fbListenerGroup_t</a> *&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#aa0f87164ee76983beadbf79299681f20">fbAcceptCallback_fn</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A combination of ListenerGroupWait and ListenerWaitAcceptCallback. </p>
<p>It monitors the list of listeners in the group, and calls the callback if any of them find a new connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>pointer to the group to wait for connections on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>function to call when a listener in the group gets a new connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>standard error string structure in fixbuf </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a boolean AND of the results of each of the callbacks </dd></dl>

</div>
</div>
<a class="anchor" id="a7efdc23863fcb2725c6d29c575fcbaa7"></a><!-- doxytag: member="public.h::fbListenerInterrupt" ref="a7efdc23863fcb2725c6d29c575fcbaa7" args="(fbListener_t *listener)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbListenerInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cause the current or next call to fbListenerWait to unblock and return. </p>
<p>Use this from a thread or a signal handler to interrupt a blocked listener.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>listener to interrupt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc226a9f5cef7f773fe55817839179d0"></a><!-- doxytag: member="public.h::fbListenerOwnSocketCollectorTCP" ref="abc226a9f5cef7f773fe55817839179d0" args="(fbListener_t *listener, int sock, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fbListenerOwnSocketCollectorTCP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns an fBuf wrapped around an independently managed socket and a properly created listener for TCP connections. </p>
<p>The caller is only responsible for creating the socket. The existing collector code will close the socket and cleanup everything.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>pointer to the listener to wrap around the socket </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>the socket descriptor of the independently managed socket </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>standard fixbuf err structure pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the fbuf for the collector. NULL if sock is 0, 1, or 2 (stdin, stdout, or stderr) </dd></dl>

</div>
</div>
<a class="anchor" id="a3048c8b45e2d66218eaf97b2c45fdea0"></a><!-- doxytag: member="public.h::fbListenerOwnSocketCollectorTLS" ref="a3048c8b45e2d66218eaf97b2c45fdea0" args="(fbListener_t *listener, int sock, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fbListenerOwnSocketCollectorTLS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Same as fbListenerOwnSocketCollectorTCP but for TLS (not tested). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>pointer to the listener to wait on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sock</em>&nbsp;</td><td>independently managed socket descriptor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>standard fixbuf err structure pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the fbuf for the collector NULL if sock is 0, 1, or 2 (stdin, stdout, or stderr) </dd></dl>

</div>
</div>
<a class="anchor" id="a514187cc62c75d4ed92ae2e497d21a42"></a><!-- doxytag: member="public.h::fbListenerWait" ref="a514187cc62c75d4ed92ae2e497d21a42" args="(fbListener_t *listener, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fbListenerWait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait on a listener. </p>
<p>Accepts pending connections from exporting processes. Returns the next collection buffer with available data to read; if the collection buffer returned by the last call to <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a> is available, it is preferred. Blocks forever (or until <a class="el" href="public_8h.html#a7efdc23863fcb2725c6d29c575fcbaa7" title="Cause the current or next call to fbListenerWait to unblock and return.">fbListenerInterrupt()</a> is called) if no messages or connections are available.</p>
<p>To effectively use <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a>, the application should set up an session state container with internal templates, call <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a> to accept a first connection, then read records from the collector buffer to end of message (FB_ERROR_EOM). At end of message, the application should then call <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a> to accept pending connections or switch to another collector buffer with available data. Note that each collector buffer returned created by <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a> is set to manual mode using <a class="el" href="public_8h.html#a661f4cc21e726345d3e22372af33c2d1" title="Set the automatic mode flag on a buffer.">fBufSetAutomaticMode()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>a listener </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a collection buffer with available data, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a98291cffaaf2b8a611647a5267c00c64"></a><!-- doxytag: member="public.h::fbListenerWaitAcceptCallback" ref="a98291cffaaf2b8a611647a5267c00c64" args="(fbListener_t *listener, fbAcceptCallback_fn callback, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbListenerWaitAcceptCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#aa0f87164ee76983beadbf79299681f20">fbAcceptCallback_fn</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Takes one listener, and instead of returning the fBuf created from the new collector, like <a class="el" href="public_8h.html#a514187cc62c75d4ed92ae2e497d21a42" title="Wait on a listener.">fbListenerWait()</a>, it calls the callback function provided. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>listenr to wait on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>function to call upon receiving a new connection </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>standard fixbuf err string structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the boolean result of the callback, or FALSE plus the error string upon failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d0fd5679efb1df055c72cfc10189363"></a><!-- doxytag: member="public.h::fbListenerWaitNoCollectors" ref="a0d0fd5679efb1df055c72cfc10189363" args="(fbListener_t *listener, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fbListenerWaitNoCollectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a> *&nbsp;</td>
          <td class="paramname"> <em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for an incoming connection, just like fbListenerWait, except that this function doesn't monitor active collectors. </p>
<p>This allows for a multi threaded application to have one thread monitoring the listeners, and one keeping track of collectors </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>listener</em>&nbsp;</td><td>The listener to wait for connections on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a collection buffer for the new connection, NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a357399fb037ea9b0b6e0c641a8f40cec"></a><!-- doxytag: member="public.h::fbListValidSemantic" ref="a357399fb037ea9b0b6e0c641a8f40cec" args="(uint8_t semantic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbListValidSemantic </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>semantic</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>validates the value of the semantic field, </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>semantic</em>&nbsp;</td><td>The value of the semantic field to be validated * </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE is valid {0xFF, 0x00-0x04}, FALSE if not </dd></dl>

</div>
</div>
<a class="anchor" id="a2e4baf6d2142eca4cb526b1e80628bf8"></a><!-- doxytag: member="public.h::fbSessionAddTemplate" ref="a2e4baf6d2142eca4cb526b1e80628bf8" args="(fbSession_t *session, gboolean internal, uint16_t tid, fbTemplate_t *tmpl, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fbSessionAddTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&nbsp;</td>
          <td class="paramname"> <em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a template to a session. </p>
<p>If external, adds the template to the current domain, and exports the template if the session is associated with an export buffer. Assigns the template ID given in tid, or assigns a template ID if tid is FB_TID_AUTO. If using FB_TID_AUTO, external templates start at 256 and count up, internal templates start at 65535 and count down. This is to avoid inadvertant unrelated external and internal templates having the same ID</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>A session state container </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>internal</em>&nbsp;</td><td>TRUE if the template is internal, FALSE if external. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Template ID to assign, replacing any current template in case of collision; or FB_TID_AUTO to assign a new tId. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>Template to add </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>An error description, set on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the template ID of the added template, or 0 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a571e85ca2f6c01b1c94932e546b978e9"></a><!-- doxytag: member="public.h::fbSessionAddTemplateCallback" ref="a571e85ca2f6c01b1c94932e546b978e9" args="(fbSession_t *session, fbNewTemplateCallback_fn callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionAddTemplateCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a5c72c26427ae0efc734862b95cb09ae9">fbNewTemplateCallback_fn</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function sets the callback to let the user know when a new template has arrived from the connected IPFIX node. </p>
<p>Assigning a callback here is NOT required. Not using one will cause all sub templates to be fully decoded, transcoding all information elements in the external template. This function needs to be called AFTER a new connection has been made, usually after the call to fbListenerWait, which creates a new fBuf and session for that connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>pointer to the session to assign the callback to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>the function to be called when a new template is received </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a1b142aa40a63aab16b297c77649f3d5c"></a><!-- doxytag: member="public.h::fbSessionAddTemplatePair" ref="a1b142aa40a63aab16b297c77649f3d5c" args="(fbSession_t *session, uint16_t ent_tid, uint16_t int_tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionAddTemplatePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>ent_tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>int_tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an external-internal template pair to the session. </p>
<p>This tells the transcoder which internal template to use for a given external template used in a sub template list, or a sub template multi list</p>
<p>If ent_tid and int_tid are set equal to each other, it tells the transcoder to decode all of the fields from the external template, by using the external template also as the internal template (lining up all the fields) The exception to this is if there is an existing internal template with the same template ID as the external template. In this case, the internal template with the appropriate ID will be used. To avoid this potentially unintended consequence, be careful and deliberate with template IDs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>pointer to the session to add the pair to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ent_tid</em>&nbsp;</td><td>the external template ID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int_tid</em>&nbsp;</td><td>the internal template ID used to decode the data when the associated external template is used </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="ace1d8a4523d098e625d5330e0d15bd4b"></a><!-- doxytag: member="public.h::fbSessionAlloc" ref="ace1d8a4523d098e625d5330e0d15bd4b" args="(fbInfoModel_t *model)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a>* fbSessionAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&nbsp;</td>
          <td class="paramname"> <em>model</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a transport session state container. </p>
<p>The new session is associated with the given information model, contains no templates, and is usable either for collection or export.</p>
<p>Each fbExporter_t, fbListener_t, and fbCollector_t must have its own session; session state cannot be shared.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>model</em>&nbsp;</td><td>An information model. Not freed by sessionFree. Must be freed by user after calling SessionFree </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new, empty session state container. </dd></dl>

</div>
</div>
<a class="anchor" id="a9236bdb53a94cd19bad3fef2c9bfb947"></a><!-- doxytag: member="public.h::fbSessionExportTemplate" ref="a9236bdb53a94cd19bad3fef2c9bfb947" args="(fbSession_t *session, uint16_t tid, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbSessionExportTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Export a single external template in the current domain of a given session. </p>
<p>Writes the template to the associated export buffer. May cause a message to be emitted if the associated export buffer is in automatic mode, or return with FB_ERROR_EOM if the associated export buffer is not in automatic mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a session state container associated with an export buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>template ID within current domain to export </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e0c42fc80985c048190203257697ab6"></a><!-- doxytag: member="public.h::fbSessionExportTemplates" ref="a4e0c42fc80985c048190203257697ab6" args="(fbSession_t *session, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbSessionExportTemplates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Export all external templates in the current domain of a given session. </p>
<p>Writes templates to the associated export buffer. May cause a message to be emitted if the associated export buffer is in automatic mode, or return with FB_ERROR_EOM if the associated export buffer is not in automatic mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a session state container associated with an export buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d6672c72da8b767025ff9bd5bb54a82"></a><!-- doxytag: member="public.h::fbSessionFree" ref="a4d6672c72da8b767025ff9bd5bb54a82" args="(fbSession_t *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a transport session state container. </p>
<p>This is done automatically when freeing the listener or buffer with which the session is associated. Use this call if a session needs to be destroyed before it is associated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>session state container to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b4577b6072c238c6d56f08555191ebb"></a><!-- doxytag: member="public.h::fbSessionGetDomain" ref="a4b4577b6072c238c6d56f08555191ebb" args="(fbSession_t *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbSessionGetDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the current domain on a session. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a session state container </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the ID of the session's current observation domain </dd></dl>

</div>
</div>
<a class="anchor" id="a0bf0ea7e68b9e58aa3fe8e0fbdc1e713"></a><!-- doxytag: member="public.h::fbSessionGetTemplate" ref="a0bf0ea7e68b9e58aa3fe8e0fbdc1e713" args="(fbSession_t *session, gboolean internal, uint16_t tid, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_template__st.html">fbTemplate_t</a>* fbSessionGetTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&nbsp;</td>
          <td class="paramname"> <em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a template from a session by ID. </p>
<p>If external, retrieves the template within the current domain.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>A session state container </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>internal</em>&nbsp;</td><td>TRUE if the template is internal, FALSE if external. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>ID of the template to retrieve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The template with the given ID, or NULL on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a7d63552a3f19493ec9e05c6826f3a6ed"></a><!-- doxytag: member="public.h::fbSessionLookupTemplatePair" ref="a7d63552a3f19493ec9e05c6826f3a6ed" args="(fbSession_t *session, uint16_t ext_tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fbSessionLookupTemplatePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>ext_tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to find a pair, uniquely identified by the external ID, and return the associated internal template ID. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>pointer to the session used to find the pair </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ext_tid</em>&nbsp;</td><td>external template ID used to find a pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the internal template ID from the pair. 0 if the pair isn't found </dd></dl>

</div>
</div>
<a class="anchor" id="a26aa6df19f1e9118c957d2b2359021d0"></a><!-- doxytag: member="public.h::fbSessionRemoveTemplate" ref="a26aa6df19f1e9118c957d2b2359021d0" args="(fbSession_t *session, gboolean internal, uint16_t tid, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbSessionRemoveTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&nbsp;</td>
          <td class="paramname"> <em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a template from a session. </p>
<p>If external, removes the template from the current domain, and exports a template revocation set if the session is associated with an export buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>A session state container </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>internal</em>&nbsp;</td><td>TRUE if the template is internal, FALSE if external. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>Template ID to remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>An error description, set on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ae285ec588b2c18d3e57ff92ee4090ce5"></a><!-- doxytag: member="public.h::fbSessionRemoveTemplatePair" ref="ae285ec588b2c18d3e57ff92ee4090ce5" args="(fbSession_t *session, uint16_t ext_tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionRemoveTemplatePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>ext_tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>remove a template pair from the list this is called by fixbuf when a template is revoked from the session by the node on the other end of the connection </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>pointer to the session to remove the pair from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ext_tid</em>&nbsp;</td><td>the external template ID for the pair </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="ac7ebb73e4655052664d69e9b1876543d"></a><!-- doxytag: member="public.h::fbSessionResetExternal" ref="ac7ebb73e4655052664d69e9b1876543d" args="(fbSession_t *session)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionResetExternal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the external state (sequence numbers and templates) in a session state container. </p>
<p>FIXME: Verify that this call actually makes sense; either that a session is reassociatable with a new collector, or that you need to do this when reassociating a collector with a connection. Once this is done, rewrite this documentation</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>session state container to reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80f2a7b352786c72e05738a5f1d4f293"></a><!-- doxytag: member="public.h::fbSessionSetDomain" ref="a80f2a7b352786c72e05738a5f1d4f293" args="(fbSession_t *session, uint32_t domain)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSessionSetDomain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>domain</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the current observation domain on a session. </p>
<p>The domain is used to scope sequence numbers and external templates. This is called automatically during collection, but must be called to set the domain for export before adding external templates or writing records.</p>
<p>Notice that a domain change does not automatically cause any associated export buffers to emit messages; a domain change takes effect with the next message started. Therefore, call <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint...">fBufEmit()</a> before setting the domain on the buffer's associated session.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a session state container </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>domain</em>&nbsp;</td><td>ID of the observation domain to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1974da5e6837cdfb2d0a17d7efc338ef"></a><!-- doxytag: member="public.h::fbSubTemplateListAddNewElements" ref="a1974da5e6837cdfb2d0a17d7efc338ef" args="(fbSubTemplateList_t *subTemplateList, uint16_t numNewElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListAddNewElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>numNewElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates space for a number of additional element in the sub template list must be called after the list has been <a class="el" href="public_8h.html#a499616fc3525e481de877d726d7ada00" title="Initializes a subTemplateList structure and alloc&#39;s the dataPtr to get a buffer...">fbSubTemplateListInit()</a>'d. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateList</em>&nbsp;</td><td>pointer to the sub template list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numNewElements</em>&nbsp;</td><td>number of new elements to add to the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the first newly allocated element </dd></dl>

</div>
</div>
<a class="anchor" id="a929f24a1af3566fc5a57d13ba7d520fc"></a><!-- doxytag: member="public.h::fbSubTemplateListAlloc" ref="a929f24a1af3566fc5a57d13ba7d520fc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a>* fbSubTemplateListAlloc </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a subTemplateList_t Based on how subTemplateLists will be used and set up amidst data structures, this function may never be used. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the new sub template list </dd></dl>

</div>
</div>
<a class="anchor" id="adab25ac70317a2b857ef7acea86ae582"></a><!-- doxytag: member="public.h::fbSubTemplateListClear" ref="adab25ac70317a2b857ef7acea86ae582" args="(fbSubTemplateList_t *subTemplateListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears a subtemplate list struct, notably freeing the dataPtr and setting it to NULL. </p>
<p>This should be used after each call to fBufNext: If the dataPtr is not NULL in DecodeSubTemplateList, it will not allocate new memory for the new record, which could cause a buffer overflow if the new record has a longer list than the current one. An alternative is to allocate a large buffer and assign it to dataPtr on your own, then never clear it with this. Be certain this buffer is longer than needed for all possible lists </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the sub template list to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="ad6a97dee08969e092dff301ac73766e7"></a><!-- doxytag: member="public.h::fbSubTemplateListClearWithoutFree" ref="ad6a97dee08969e092dff301ac73766e7" args="(fbSubTemplateList_t *subTemplateListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListClearWithoutFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the sub template list parameters but does not free the data ptr. </p>
<p>This is used in conjuction with STLInitOwnBuffer because that buffer is allocated at the beginning by the user and will be freed at the end by the user, outside of fixbuf api calls </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the sub template list to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="af0f0c40ed3a5bb9f0da695f098b1d0c3"></a><!-- doxytag: member="public.h::fbSubTemplateListCollectorInit" ref="af0f0c40ed3a5bb9f0da695f098b1d0c3" args="(fbSubTemplateList_t *STL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListCollectorInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STL</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes a sub template list variable on a collector. </p>
<p>If the fbSubTemplateList variable is in a struct, it will likely not be set to 0's If not, the dataPtr will not be NULL, so the transcoder will not allocate the right memory for it, as it will assuming it's set up. This will break. Call this function right after declaring the struct variable that contains the fbSubTemplateList. It only needs to be called once for each STL </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STL</em>&nbsp;</td><td>pointer to the sub template list to initialize for collection </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="aa724aa4ec311288e02dfab42cf23c355"></a><!-- doxytag: member="public.h::fbSubTemplateListFree" ref="aa724aa4ec311288e02dfab42cf23c355" args="(fbSubTemplateList_t *subTemplateListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees and clears a subTemplateList struct. </p>
<p>This frees the dataPtr AND frees the memory pointed to by the subTemplateListPtr Used in conjunction with subTemplateListAlloc(), unlikely to be used </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the sub template list to free </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a91c7e51169df7680c9db96befde9cd74"></a><!-- doxytag: member="public.h::fbSubTemplateListGetDataPtr" ref="a91c7e51169df7680c9db96befde9cd74" args="(const fbSubTemplateList_t *subTemplateListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListGetDataPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to the buffer that contains the data for the list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the STL to get the pointer from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the data buffer used by the sub template list </dd></dl>

</div>
</div>
<a class="anchor" id="abcc3c1f936517485ba2ed23945273da7"></a><!-- doxytag: member="public.h::fbSubTemplateListGetIndexedDataPtr" ref="abcc3c1f936517485ba2ed23945273da7" args="(const fbSubTemplateList_t *subTemplateListPtr, uint16_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListGetIndexedDataPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is used to iterate over the elements in the list by passing in a counter to indicate which element is to be returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the STL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the element to be retrieved (0-based) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the desired element. NULL if index &gt;= numElements </dd></dl>

</div>
</div>
<a class="anchor" id="aee412c835fa0ee64eb4a7fc67975e69b"></a><!-- doxytag: member="public.h::fbSubTemplateListGetNextPtr" ref="aee412c835fa0ee64eb4a7fc67975e69b" args="(const fbSubTemplateList_t *subTemplateListPtr, void *currentPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListGetNextPtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>currentPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function also traverses the elements in the list by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element. </p>
<p>A current element of NULL tells the function to return the first element in the list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the STL to get data from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentPtr</em>&nbsp;</td><td>pointer to the last element accessed. NULL causes the pointer to the first element to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the next element in the list. Returns NULL if currentPtr points to the last element in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="af0f68a07d50e046fde0d1cfb315ca0e7"></a><!-- doxytag: member="public.h::fbSubTemplateListGetSemantic" ref="af0f68a07d50e046fde0d1cfb315ca0e7" args="(fbSubTemplateList_t *subTemplateListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fbSubTemplateListGetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the semantic value from a sub template list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the sub template list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the semantic field from the list </dd></dl>

</div>
</div>
<a class="anchor" id="a63643493a19bce4564676fbf6b0294b9"></a><!-- doxytag: member="public.h::fbSubTemplateListGetTemplate" ref="a63643493a19bce4564676fbf6b0294b9" args="(fbSubTemplateList_t *subTemplateListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structfb_template__st.html">fbTemplate_t</a>* fbSubTemplateListGetTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the template pointer from the list structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the sub template list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the template used by the sub template list </dd></dl>

</div>
</div>
<a class="anchor" id="a26cd7af13bdc03147832e868ee3a648f"></a><!-- doxytag: member="public.h::fbSubTemplateListGetTemplateID" ref="a26cd7af13bdc03147832e868ee3a648f" args="(fbSubTemplateList_t *subTemplateListPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fbSubTemplateListGetTemplateID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the template ID for the template used by the list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the sub template list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the template ID used by the sub template list </dd></dl>

</div>
</div>
<a class="anchor" id="a499616fc3525e481de877d726d7ada00"></a><!-- doxytag: member="public.h::fbSubTemplateListInit" ref="a499616fc3525e481de877d726d7ada00" args="(fbSubTemplateList_t *sTL, uint8_t semantic, uint16_t tmplID, const fbTemplate_t *tmpl, uint16_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>sTL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>tmplID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes a subTemplateList structure and alloc's the dataPtr to get a buffer able to hold numElements in the template This will mainly be used in exporters preparing to encode. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sTL</em>&nbsp;</td><td>pointer to the sub template list to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>semantic</em>&nbsp;</td><td>the semantic value used to describe the list contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmplID</em>&nbsp;</td><td>id of the template used for encoding the list data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>pointer to the template struct used for encoding the list data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements in the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the allocated buffer (location of first element) </dd></dl>

</div>
</div>
<a class="anchor" id="af107185a4e7b9bf3ca1c086f3e170831"></a><!-- doxytag: member="public.h::fbSubTemplateListInitWithOwnBuffer" ref="af107185a4e7b9bf3ca1c086f3e170831" args="(fbSubTemplateList_t *subTemplateList, uint8_t semantic, uint16_t tmplID, const fbTemplate_t *tmpl, uint16_t numElements, uint16_t dataLength, uint8_t *dataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListInitWithOwnBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>tmplID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>dataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the subTemplateList but does not allocate a buffer. </p>
<p>It accepts a previously allocated buffer and data length and uses it. This will generally be used in collectors providing their own buffer</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateList</em>&nbsp;</td><td>pointer to the sub template list to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>semantic</em>&nbsp;</td><td>the semantic value used to describe the list contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmplID</em>&nbsp;</td><td>id of the template used for encoding the list data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>pointer to the template struct used for encoding the list data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of elements in the list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dataLength</em>&nbsp;</td><td>length of the data buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dataPtr</em>&nbsp;</td><td>pointer to the previously allocated data buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to that buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a2c40d213552ca0d27b9c60ce0fbc1383"></a><!-- doxytag: member="public.h::fbSubTemplateListRealloc" ref="a2c40d213552ca0d27b9c60ce0fbc1383" args="(fbSubTemplateList_t *subTemplateList, uint16_t newNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateListRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>newNumElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the current data pointer, allocating a new buffer to accomodate the new number of elements. </p>
<p>The remaining parameters are unchanged. If the number of elements hasn't changed the original buffer is used and its pointer is returned</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateList</em>&nbsp;</td><td>pointer to the sub template list to realloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newNumElements</em>&nbsp;</td><td>value for the new number of elements for the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the data buffer after realloc </dd></dl>

</div>
</div>
<a class="anchor" id="aea90a84a945c348970d6f24694d761a0"></a><!-- doxytag: member="public.h::fbSubTemplateListSetSemantic" ref="aea90a84a945c348970d6f24694d761a0" args="(fbSubTemplateList_t *subTemplateListPtr, uint8_t semantic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateListSetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_list__st.html">fbSubTemplateList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subTemplateListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>semantic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the semantic parameter of a subTemplateList. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>subTemplateListPtr</em>&nbsp;</td><td>pointer to the sub template list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>semantic</em>&nbsp;</td><td>Semantic value for the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a37ea8ee69f101c7d787c8b64bf76c0b8"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListAddNewEntries" ref="a37ea8ee69f101c7d787c8b64bf76c0b8" args="(fbSubTemplateMultiList_t *STML, uint16_t numNewEntries)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListAddNewEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>numNewEntries</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds entries to the multi list of entries can only be run after the list has been initialized. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template multi list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numNewEntries</em>&nbsp;</td><td>number of entries to add to the list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to the new entry </dd></dl>

</div>
</div>
<a class="anchor" id="a32b01b970a85e30ab72701da7059ae57"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListClear" ref="a32b01b970a85e30ab72701da7059ae57" args="(fbSubTemplateMultiList_t *STML)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears all of the entries (frees their data pointers), then frees the memory containing the entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template mutli list to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="aa0c4272a3052cbc6d6385d449f258600"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListClearEntries" ref="aa0c4272a3052cbc6d6385d449f258600" args="(fbSubTemplateMultiList_t *STML)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListClearEntries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the memory used by the entries of a sub template multi list NOTE: if any of those entries contain another layer of structures, that second layer must be freed by the user, this function cannot do that. </p>
<p>example: an entry's template contains an element of type basicList. The memory used by that basicList isn't freed by this function </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="aab5362c194595441d9b3cf96f1d92a0d"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListEntryClear" ref="aab5362c194595441d9b3cf96f1d92a0d" args="(fbSubTemplateMultiListEntry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListEntryClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the memory pointed to by the data buffer holding the data elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>pointer to the entry to clear the contents of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="acb3325df690ba3bff4cb9b691a5fe307"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListEntryGetDataPtr" ref="acb3325df690ba3bff4cb9b691a5fe307" args="(fbSubTemplateMultiListEntry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryGetDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the data pointer for this entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>pointer to the entry to get the data pointer from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the buffer used to store data for this entry </dd></dl>

</div>
</div>
<a class="anchor" id="af1152a67d46b10b2f0a6550506f06d02"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListEntryGetIndexedPtr" ref="af1152a67d46b10b2f0a6550506f06d02" args="(fbSubTemplateMultiListEntry_t *entry, uint16_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryGetIndexedPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a pointer to a data element in the entry based on the index. </p>
<p>If the index is &gt;= to the number of elements in the list, NULL is returned. The elements are 0-based, so index = 0 is returns the first elements.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>pointer to the entry to get a data pointer from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>the number of the element in the list to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the index'th element used by the entry NULL if the index is &gt;= numElements </dd></dl>

</div>
</div>
<a class="anchor" id="a27841bb33f91bbf856c49cd1c0ee32d9"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListEntryGetTemplate" ref="a27841bb33f91bbf856c49cd1c0ee32d9" args="(fbSubTemplateMultiListEntry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structfb_template__st.html">fbTemplate_t</a>* fbSubTemplateMultiListEntryGetTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the template pointer used to structure the data elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>pointer to the entry to get the template from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the template pointer used to describe the contents of the entry </dd></dl>

</div>
</div>
<a class="anchor" id="a87c7ce2b006144807f49d6388309d983"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListEntryGetTemplateID" ref="a87c7ce2b006144807f49d6388309d983" args="(fbSubTemplateMultiListEntry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t fbSubTemplateMultiListEntryGetTemplateID </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the template ID for the template used to structure the data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>pointer to the entry to get the template ID from </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the template ID for template that describes the data </dd></dl>

</div>
</div>
<a class="anchor" id="ab3d07cd5e507e5ebac4e9ca32c776636"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListEntryInit" ref="ab3d07cd5e507e5ebac4e9ca32c776636" args="(fbSubTemplateMultiListEntry_t *entry, uint16_t tmplID, fbTemplate_t *tmpl, uint16_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>tmplID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the multi list entry with the template values, and allocates the memory used by the entry to hold the data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>pointer to the entry to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmplID</em>&nbsp;</td><td>ID of the template used to structure the data elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>pointer to the template used to structure the data elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of data elements in the entry</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the data buffer to be filled in </dd></dl>

</div>
</div>
<a class="anchor" id="a1bb644017749befbc7337a9839642ad5"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListEntryNextDataPtr" ref="a1bb644017749befbc7337a9839642ad5" args="(fbSubTemplateMultiListEntry_t *entry, void *currentPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryNextDataPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>currentPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function traverses the elements in the entry by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element. </p>
<p>A current element of NULL tells the function to return the first element in the list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>pointer to the entry to get the next element from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentPtr</em>&nbsp;</td><td>pointer to the last element accessed. NULL means return a pointer to the first element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the next element in the list. Returns NULL if currentPtr points to the last element in the list </dd></dl>

</div>
</div>
<a class="anchor" id="a8b35725d9ae682581eaba7bb5f1caefb"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListEntryRealloc" ref="a8b35725d9ae682581eaba7bb5f1caefb" args="(fbSubTemplateMultiListEntry_t *entry, uint16_t newNumElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbSubTemplateMultiListEntryRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>newNumElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the memory for the data used by the entry, then allocates a new buffer based on the size of the template and newNumElements. </p>
<p>(if numElements doesn't change, the pointer is returned without freeing and allocating)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>pointer to the entry to realloc </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newNumElements</em>&nbsp;</td><td>the new number of elements for the entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to buffer to write data to </dd></dl>

</div>
</div>
<a class="anchor" id="ab66fd48ac8abd256e4310962aa8c6728"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListFree" ref="ab66fd48ac8abd256e4310962aa8c6728" args="(fbSubTemplateMultiList_t *STML)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the multi list, then frees the memory pointed to by STML. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a2dfe6e3994cd27f0f2c2863cbc9accd6"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListGetFirstEntry" ref="a2dfe6e3994cd27f0f2c2863cbc9accd6" args="(fbSubTemplateMultiList_t *STML)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListGetFirstEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the first entry in the multi list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the first entry used by the list </dd></dl>

</div>
</div>
<a class="anchor" id="a8234b166da13c96cc3e70c9ca1c57ba9"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListGetIndexedEntry" ref="a8234b166da13c96cc3e70c9ca1c57ba9" args="(fbSubTemplateMultiList_t *STML, uint16_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListGetIndexedEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a pointer to the entry of a specific index. </p>
<p>The entry indexes are zero based. NULL is returned if the index requested is too high </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template mutli list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>index of the entry to be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index'th entry used by the list. NULL If index &gt;= numElements </dd></dl>

</div>
</div>
<a class="anchor" id="a7e320134f6cbe6bb42cf2ff353b52636"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListGetNextEntry" ref="a7e320134f6cbe6bb42cf2ff353b52636" args="(fbSubTemplateMultiList_t *STML, fbSubTemplateMultiListEntry_t *currentEntry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListGetNextEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a> *&nbsp;</td>
          <td class="paramname"> <em>currentEntry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function also traverses the elements in the list by accepting a pointer to the last element the user accessed, moves it to the next element and returns a pointer to the next element. </p>
<p>A current element of NULL tells the function to return the first element in the list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template multi list to get data from </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentEntry</em>&nbsp;</td><td>pointer to the last element accessed. NULL means none have been accessed yet </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pointer to the next element in the list. Returns the NULL if currentEntry points to the last entry. </dd></dl>

</div>
</div>
<a class="anchor" id="af75970c32e64a7799d61fe32be1ad5c7"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListGetSemantic" ref="af75970c32e64a7799d61fe32be1ad5c7" args="(fbSubTemplateMultiList_t *STML)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t fbSubTemplateMultiListGetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the semantic paramter from the multi list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>semantic parameter describing the contents of the multi list </dd></dl>

</div>
</div>
<a class="anchor" id="a3d3c58aebb9dcb758be9fa7eef314781"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListInit" ref="a3d3c58aebb9dcb758be9fa7eef314781" args="(fbSubTemplateMultiList_t *STML, uint8_t semantic, uint16_t numElements)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>semantic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>numElements</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the multi list with semantic, numbers of elements, and allocates memory to store numElements worth of entries. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template multi list to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>semantic</em>&nbsp;</td><td>value used to describe the entries in the multi list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numElements</em>&nbsp;</td><td>number of entries in the multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the first uninitialized entry </dd></dl>

</div>
</div>
<a class="anchor" id="a8cbfaabfe3526969d1bb61b6b68699a6"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListRealloc" ref="a8cbfaabfe3526969d1bb61b6b68699a6" args="(fbSubTemplateMultiList_t *STML, uint16_t newNumEntries)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_sub_template_multi_list_entry__st.html">fbSubTemplateMultiListEntry_t</a>* fbSubTemplateMultiListRealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>newNumEntries</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the entries used by the multi list, then if newNumElements is different than numElements, frees the entries buffer and allocates a new one. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template mutli list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newNumEntries</em>&nbsp;</td><td>the new number of entries for the STML </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the first entry </dd></dl>

</div>
</div>
<a class="anchor" id="a4a8185ac0dfdd2535fb338bddbc4948d"></a><!-- doxytag: member="public.h::fbSubTemplateMultiListSetSemantic" ref="a4a8185ac0dfdd2535fb338bddbc4948d" args="(fbSubTemplateMultiList_t *STML, uint8_t semantic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbSubTemplateMultiListSetSemantic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_sub_template_multi_list__st.html">fbSubTemplateMultiList_t</a> *&nbsp;</td>
          <td class="paramname"> <em>STML</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>semantic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the semantic field for the multi list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>STML</em>&nbsp;</td><td>pointer to the sub template multi list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>semantic</em>&nbsp;</td><td>Value for the semantic field of the sub template multi list </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NONE </dd></dl>

</div>
</div>
<a class="anchor" id="a6dad36eadf23739de4fe77ae466c0c7d"></a><!-- doxytag: member="public.h::fbTemplateAlloc" ref="a6dad36eadf23739de4fe77ae466c0c7d" args="(fbInfoModel_t *model)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_template__st.html">fbTemplate_t</a>* fbTemplateAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a7403b5635628fcc24eeb03b73c0b08bd">fbInfoModel_t</a> *&nbsp;</td>
          <td class="paramname"> <em>model</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a new empty template. </p>
<p>The template will be associated with the given Information Model, and only able to use Information Elements defined within that Information Model. Templates may be associated with multiple sessions, with different template IDs each time, and as such are reference counted and owned by sessions. A template must be associated with at least one session or it will be leaked; each template is freed after its last associated session is freed.</p>
<p>Use <a class="el" href="public_8h.html#a06ca9d2de7767f09ddcaa50651ff5b7c" title="Append an information element to a template.">fbTemplateAppend()</a>, <a class="el" href="public_8h.html#a3507ead494bd3957d325565c66660e79" title="Append an information element described by specifier to a template.">fbTemplateAppendSpec()</a>, and <a class="el" href="public_8h.html#acb8f6399ecdbbc6af8fbacedc4e49a6c" title="Append information elements described by a specifier array to a template.">fbTemplateAppendSpecArray()</a> to "fill in" a template after creating it, and before associating it with any session.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>model</em>&nbsp;</td><td>An information model </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new, empty Template. </dd></dl>

</div>
</div>
<a class="anchor" id="a06ca9d2de7767f09ddcaa50651ff5b7c"></a><!-- doxytag: member="public.h::fbTemplateAppend" ref="a06ca9d2de7767f09ddcaa50651ff5b7c" args="(fbTemplate_t *tmpl, fbInfoElement_t *ex_ie, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateAppend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ex_ie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an information element to a template. </p>
<p>The information element is taken to be an example; the canonical element from the template's associated model is looked up by enterprise and element number and copied. If no information element exists in the model with the given enterprise and element number, it is copied to the model with the name "_alienInformationElement".</p>
<p>This call is intended primarily for use by fBuf_t's template reader, but can also be useful to simulate receipt of templates over the wire.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>Template to append information element to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ex_ie</em>&nbsp;</td><td>Example IE to add to the template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a3507ead494bd3957d325565c66660e79"></a><!-- doxytag: member="public.h::fbTemplateAppendSpec" ref="a3507ead494bd3957d325565c66660e79" args="(fbTemplate_t *tmpl, fbInfoElementSpec_t *spec, uint32_t flags, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateAppendSpec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append an information element described by specifier to a template. </p>
<p>The information element named by the specifier is copied from the template's associated model, and the length and flags are overriden from the specifier.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>Template to append information element to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>Specifier describing information element to append. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Application flags. Must match one bit of spec flags word or the append will be silently skipped. Used for building multiple templates with different information element features from a single specifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="acb8f6399ecdbbc6af8fbacedc4e49a6c"></a><!-- doxytag: member="public.h::fbTemplateAppendSpecArray" ref="acb8f6399ecdbbc6af8fbacedc4e49a6c" args="(fbTemplate_t *tmpl, fbInfoElementSpec_t *spec, uint32_t flags, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateAppendSpecArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append information elements described by a specifier array to a template. </p>
<p>The information elements named by the specifiers are copied from the template's associated model, and the length and flags are overriden from each specifier. The array is read until the FB_IESPEC_NULL convenience macro is encountered.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>Template to append information element to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>Pointer to first specifier in specifier array to append. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>Application flags. Must contain all bits of spec flags word or the append will be silently skipped. Used for building multiple templates with different information element features from a single specifier. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a77d6b67bc472d0c5d9519705e4762b0b"></a><!-- doxytag: member="public.h::fbTemplateContainsAllElementsByName" ref="a77d6b67bc472d0c5d9519705e4762b0b" args="(fbTemplate_t *tmpl, fbInfoElementSpec_t *spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateContainsAllElementsByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a template contains at least one instance of each information element in a given information element specifier array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>Template to search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>Pointer to specifier array to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the template contains all the given IEs </dd></dl>

</div>
</div>
<a class="anchor" id="a12f92cdd32c7b3d3b2cd868169e94df9"></a><!-- doxytag: member="public.h::fbTemplateContainsElement" ref="a12f92cdd32c7b3d3b2cd868169e94df9" args="(fbTemplate_t *tmpl, const fbInfoElement_t *ex_ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateContainsElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structfb_info_element__st.html">fbInfoElement_t</a> *&nbsp;</td>
          <td class="paramname"> <em>ex_ie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a template contains a given information element. </p>
<p>Matches against information element private enterprise number, number, and multiple-IE index (i.e., to determine if a given template contains six instances of a given information element, set ex_ie-&gt;midx = 5 before this call).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>Template to search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ex_ie</em>&nbsp;</td><td>Pointer to an information element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the template contains the given IE </dd></dl>

</div>
</div>
<a class="anchor" id="afefdba7c60efb314f90945a4c3871990"></a><!-- doxytag: member="public.h::fbTemplateContainsElementByName" ref="afefdba7c60efb314f90945a4c3871990" args="(fbTemplate_t *tmpl, fbInfoElementSpec_t *spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fbTemplateContainsElementByName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfb_info_element_spec__st.html">fbInfoElementSpec_t</a> *&nbsp;</td>
          <td class="paramname"> <em>spec</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if a template contains at least one instance of a given information element, specified by name in the template's information model. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>Template to search </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>Specifier of information element to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the template contains the given IE </dd></dl>

</div>
</div>
<a class="anchor" id="ae789e65af95fb99fcab61474288104ce"></a><!-- doxytag: member="public.h::fbTemplateCountElements" ref="ae789e65af95fb99fcab61474288104ce" args="(fbTemplate_t *tmpl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbTemplateCountElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine number of information elements in a template. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>A template </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>information element count </dd></dl>

</div>
</div>
<a class="anchor" id="a0876c0ada0d62b708c7e202c18011380"></a><!-- doxytag: member="public.h::fbTemplateFreeUnused" ref="a0876c0ada0d62b708c7e202c18011380" args="(fbTemplate_t *tmpl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbTemplateFreeUnused </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a template if it is not currently in use by any Session. </p>
<p>Use this to clean up while creating templates in case of error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>template to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a363e2261bf5a74d6efe0f64b19602454"></a><!-- doxytag: member="public.h::fbTemplateGetOptionsScope" ref="a363e2261bf5a74d6efe0f64b19602454" args="(fbTemplate_t *tmpl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fbTemplateGetOptionsScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine number of scope information elements in a template. </p>
<p>The template is an options template if nonzero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>A template </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>scope information element count </dd></dl>

</div>
</div>
<a class="anchor" id="a9c24d42f54d9f367db257e2d0df9b451"></a><!-- doxytag: member="public.h::fbTemplateSetOptionsScope" ref="a9c24d42f54d9f367db257e2d0df9b451" args="(fbTemplate_t *tmpl, uint16_t scope_count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbTemplateSetOptionsScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfb_template__st.html">fbTemplate_t</a> *&nbsp;</td>
          <td class="paramname"> <em>tmpl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>scope_count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the number of information elements in a template that are scope. </p>
<p>This causes the template to become an options template, and must be called after all the scope information elements have been appended to the template.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tmpl</em>&nbsp;</td><td>Template to set scope on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scope_count</em>&nbsp;</td><td>Number of scope information elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71b2a64c7d212e9c3562388b95b993ab"></a><!-- doxytag: member="public.h::fBufAllocForCollection" ref="a71b2a64c7d212e9c3562388b95b993ab" args="(fbSession_t *session, fbCollector_t *collector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fBufAllocForCollection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a new buffer for collection. </p>
<p>Associates the buffer with a given session and collecting process endpoint; these become owned by the buffer. Session and collector are freed by fBufFree. Must not be freed by user</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a session initialized with appropriate internal templates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>an collecting process endpoint </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new IPFIX message buffer, owning the session and collector, for collection use via <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a> and <a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479" title="Read a new message into a buffer using the associated collecting process endpoint...">fBufNextMessage()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fb7c1a2229e3e8c15c04a215c92329b"></a><!-- doxytag: member="public.h::fBufAllocForExport" ref="a2fb7c1a2229e3e8c15c04a215c92329b" args="(fbSession_t *session, fbExporter_t *exporter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a>* fBufAllocForExport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>session</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exporter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate a new buffer for export. </p>
<p>Associates the buffer with a given session and exporting process endpoint; these become owned by the buffer. Session and exporter are freed by fBufFree. Must never be freed by user</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>session</em>&nbsp;</td><td>a session initialized with appropriate internal and external templates </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exporter</em>&nbsp;</td><td>an exporting process endpoint </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new IPFIX message buffer, owning the session and exporter, for export use via <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a> and <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint...">fBufEmit()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3fdaa8626ff753c5b617707698c22b6"></a><!-- doxytag: member="public.h::fBufAppend" ref="ad3fdaa8626ff753c5b617707698c22b6" args="(fBuf_t *fbuf, uint8_t *recbase, size_t recsize, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufAppend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>recbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>recsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Append a record to a buffer. </p>
<p>Uses the present internal template set via <a class="el" href="public_8h.html#a28c6c56234351a793fd513b212bd31b8" title="Set the internal template on a buffer to the given template ID.">fBufSetInternalTemplate()</a> to describe the record of size recsize located in memory at recbase. Uses the present export template set via <a class="el" href="public_8h.html#af6cd20b1eb9a3287f17587888ee2476b" title="Set the external template for export on a buffer to the given template ID.">fBufSetExportTemplate()</a> to describe the record structure to be written to the buffer. Information Elements present in the external template that are not present in the internal template are transcoded into the message as zeroes. If the buffer is in automatic mode, may cause a message to be emitted via <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint...">fBufEmit()</a> if there is insufficient space in the buffer for the record.</p>
<p>If the internal template contains any variable length Information Elements, those must be represented in the record by fbVarfield_t structures.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recbase</em>&nbsp;</td><td>pointer to internal record </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recsize</em>&nbsp;</td><td>size of internal record in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. Must not be NULL, as it is used internally in automatic mode to detect message restart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a3def007c235fd0dccb7a2293b23341e1"></a><!-- doxytag: member="public.h::fBufEmit" ref="a3def007c235fd0dccb7a2293b23341e1" args="(fBuf_t *fbuf, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufEmit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Emit the message currently in a buffer using the associated exporting process endpoint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a064ee09c33f86ac3b4e87320c2ae6463"></a><!-- doxytag: member="public.h::fBufFree" ref="a064ee09c33f86ac3b4e87320c2ae6463" args="(fBuf_t *fbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free a buffer. </p>
<p>Also frees any associated session, exporter, or collector, closing exporting process or collecting process endpoint connections and removing collecting process endpoints from any listeners, as necessary.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04878018c9b5d07cf7bae316da654007"></a><!-- doxytag: member="public.h::fBufGetCollectionTemplate" ref="a04878018c9b5d07cf7bae316da654007" args="(fBuf_t *fbuf, uint16_t *ext_tid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_template__st.html">fbTemplate_t</a>* fBufGetCollectionTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&nbsp;</td>
          <td class="paramname"> <em>ext_tid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the external template used to read the last record from the buffer. </p>
<p>If no record has been read, returns NULL. Stores the external template ID within the current domain in ext_tid, if not NULL.</p>
<p>This routine is not particularly useful to applications, as it would be called after the record described by the external template had been transcoded, and as such could not be used to select an appropriate internal template for a given external template. However, it is used by <a class="el" href="public_8h.html#a0be7af99ed60994dbbcfbc16701a4ace" title="Retrieve the external template that will be used to read the next record from the...">fBufNextCollectionTemplate()</a>, and may be useful in certain contexts, so is made public.</p>
<p>Usually, you'll want to use <a class="el" href="public_8h.html#a0be7af99ed60994dbbcfbc16701a4ace" title="Retrieve the external template that will be used to read the next record from the...">fBufNextCollectionTemplate()</a> instead.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ext_tid</em>&nbsp;</td><td>pointer to external template ID storage, or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the external template describing the last record read. </dd></dl>

</div>
</div>
<a class="anchor" id="a1557695deee79d0e3d053b2eda559aa8"></a><!-- doxytag: member="public.h::fBufGetCollector" ref="a1557695deee79d0e3d053b2eda559aa8" args="(fBuf_t *fbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a>* fBufGetCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the collecting process endpoint associated with a buffer. </p>
<p>The buffer must have been allocated with <a class="el" href="public_8h.html#a71b2a64c7d212e9c3562388b95b993ab" title="Allocate a new buffer for collection.">fBufAllocForCollection()</a>; otherwise, returns NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the associated collecting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="aa1569a4ca87dc52a3bb70082a2f79eb8"></a><!-- doxytag: member="public.h::fBufGetExporter" ref="aa1569a4ca87dc52a3bb70082a2f79eb8" args="(fBuf_t *fbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a>* fBufGetExporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the exporting process endpoint associated with a buffer. </p>
<p>The buffer must have been allocated with <a class="el" href="public_8h.html#a2fb7c1a2229e3e8c15c04a215c92329b" title="Allocate a new buffer for export.">fBufAllocForExport()</a>; otherwise, returns NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the associated exporting process endpoint </dd></dl>

</div>
</div>
<a class="anchor" id="a5bd3a50bb441990a1d9ae7483595578b"></a><!-- doxytag: member="public.h::fBufGetExportTime" ref="a5bd3a50bb441990a1d9ae7483595578b" args="(fBuf_t *fbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t fBufGetExportTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the export time on the message currently in a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the export time in epoch seconds. </dd></dl>

</div>
</div>
<a class="anchor" id="a0181c5c031ec9b081149d16bab6ac5e4"></a><!-- doxytag: member="public.h::fBufGetSession" ref="a0181c5c031ec9b081149d16bab6ac5e4" args="(fBuf_t *fbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="public_8h.html#a8441ccbdab7eaccc081dae0e3af32855">fbSession_t</a>* fBufGetSession </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the session associated with a buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the associated session </dd></dl>

</div>
</div>
<a class="anchor" id="aaa42fa37b56ab10897b0374360d1a401"></a><!-- doxytag: member="public.h::fBufInterruptSocket" ref="aaa42fa37b56ab10897b0374360d1a401" args="(fBuf_t *fbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufInterruptSocket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interrupts the select call of a specific collector by way of its fBuf. </p>
<p>This is mainly used by fbListenerInterrupt to interrupt all of the collector sockets well. </p>

</div>
</div>
<a class="anchor" id="a11c40f1d55e2d4b29b40eb4c07ce5ee7"></a><!-- doxytag: member="public.h::fBufNext" ref="a11c40f1d55e2d4b29b40eb4c07ce5ee7" args="(fBuf_t *fbuf, uint8_t *recbase, size_t *recsize, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>recbase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>recsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve a record from a buffer. </p>
<p>Uses the external template taken from the message to read the next record available from a data set in the message. Copies the record to a buffer at recbase, with a maximum record size pointed to by recsize, described by the present internal template set via <a class="el" href="public_8h.html#a28c6c56234351a793fd513b212bd31b8" title="Set the internal template on a buffer to the given template ID.">fBufSetInternalTemplate()</a>. Reads and processes any templates and options templates between the last record read (or beginning of message) and the next data record. Information Elements present in the internal template that are not present in the external template are transcoded into the record at recbase as zeroes. If the buffer is in automatic mode, may cause a message to be read via <a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479" title="Read a new message into a buffer using the associated collecting process endpoint...">fBufNextMessage()</a> if there are no more records available in the message buffer.</p>
<p>If the internal template contains any variable length Information Elements, those must be represented in the record at recbase by fbVarfield_t structures.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recbase</em>&nbsp;</td><td>pointer to internal record buffer; will contain record data after call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recsize</em>&nbsp;</td><td>On call, pointer to size of internal record buffer in bytes. Contains number of bytes actually transcoded at end of call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. Must not be NULL, as it is used internally in automatic mode to detect message restart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a0be7af99ed60994dbbcfbc16701a4ace"></a><!-- doxytag: member="public.h::fBufNextCollectionTemplate" ref="a0be7af99ed60994dbbcfbc16701a4ace" args="(fBuf_t *fbuf, uint16_t *ext_tid, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfb_template__st.html">fbTemplate_t</a>* fBufNextCollectionTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&nbsp;</td>
          <td class="paramname"> <em>ext_tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the external template that will be used to read the next record from the buffer. </p>
<p>If no next record is available, returns NULL. Stores the external template ID within the current domain in ext_tid, if not NULL. Reads and processes any templates and options templates between the last record read (or beginning of message) and the next data record. If the buffer is in automatic mode, may cause a message to be read via <a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479" title="Read a new message into a buffer using the associated collecting process endpoint...">fBufNextMessage()</a> if there are no more records available in the message buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ext_tid</em>&nbsp;</td><td>pointer to external template ID storage, or NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. Must not be NULL, as it is used internally in automatic mode to detect message restart. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the external template describing the last record read. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c89ee8cc9d536e1ceafb371513a6479"></a><!-- doxytag: member="public.h::fBufNextMessage" ref="a7c89ee8cc9d536e1ceafb371513a6479" args="(fBuf_t *fbuf, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufNextMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a new message into a buffer using the associated collecting process endpoint. </p>
<p>Called by <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a> on end of message in automatic mode; should be called after an FB_ERROR_EOM return from fBufNext in manual mode, or to skip the current message and go on to the next in the stream.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>an error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a661f4cc21e726345d3e22372af33c2d1"></a><!-- doxytag: member="public.h::fBufSetAutomaticMode" ref="a661f4cc21e726345d3e22372af33c2d1" args="(fBuf_t *fbuf, gboolean automatic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufSetAutomaticMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean&nbsp;</td>
          <td class="paramname"> <em>automatic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the automatic mode flag on a buffer. </p>
<p>In automatic mode, a call to <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a> or <a class="el" href="public_8h.html#a4e0c42fc80985c048190203257697ab6" title="Export all external templates in the current domain of a given session.">fbSessionExportTemplates()</a> that overruns the available space in the buffer will cause a call to <a class="el" href="public_8h.html#a3def007c235fd0dccb7a2293b23341e1" title="Emit the message currently in a buffer using the associated exporting process endpoint...">fBufEmit()</a> to emit the message in the buffer to the exporter before starting a new message; and a call to <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a> that overruns the buffer will cause a call to <a class="el" href="public_8h.html#a7c89ee8cc9d536e1ceafb371513a6479" title="Read a new message into a buffer using the associated collecting process endpoint...">fBufNextMessage()</a> to read another message from the collector before attempting to read a record. In manual mode, end of message on any buffer read/write call results in FB_ERROR_EOM. Buffers are created in automatic mode by default.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>automatic</em>&nbsp;</td><td>TRUE for this buffer to be automatic, FALSE for manual. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae808992140071be1ccbb258ea012efd0"></a><!-- doxytag: member="public.h::fBufSetCollector" ref="ae808992140071be1ccbb258ea012efd0" args="(fBuf_t *fbuf, fbCollector_t *collector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufSetCollector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#adbe40eb39792bfedc00d221c8c9f7a15">fbCollector_t</a> *&nbsp;</td>
          <td class="paramname"> <em>collector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associate an collecting process endpoint with a buffer. </p>
<p>The collector will be used to read IPFIX messgaes from a transport. The collector becomes owned by the buffer; any previous collector associated with the buffer is closed if necessary and freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>collector</em>&nbsp;</td><td>an collecting process endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbcd8b28b9e9e51c1a0ce342024b86ef"></a><!-- doxytag: member="public.h::fBufSetExporter" ref="afbcd8b28b9e9e51c1a0ce342024b86ef" args="(fBuf_t *fbuf, fbExporter_t *exporter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufSetExporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="public_8h.html#a054d6ae24ecc9fbc2e38e683d8a5481a">fbExporter_t</a> *&nbsp;</td>
          <td class="paramname"> <em>exporter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associate an exporting process endpoint with a buffer. </p>
<p>The exporter will be used to write IPFIX messgaes to a transport. The exporter becomes owned by the buffer; any previous exporter associated with the buffer is closed if necessary and freed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exporter</em>&nbsp;</td><td>an exporting process endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6cd20b1eb9a3287f17587888ee2476b"></a><!-- doxytag: member="public.h::fBufSetExportTemplate" ref="af6cd20b1eb9a3287f17587888ee2476b" args="(fBuf_t *fbuf, uint16_t ext_tid, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufSetExportTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>ext_tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the external template for export on a buffer to the given template ID. </p>
<p>The external template describes the record that will be written to the IPFIX message. The buffer must be initialized for export. The given ID is scoped to the observation domain of the associated session (see <a class="el" href="public_8h.html#a80f2a7b352786c72e05738a5f1d4f293" title="Set the current observation domain on a session.">fbSessionSetDomain()</a>), and must identify a current external template for the current domain in the buffer's associated session.</p>
<p>An export template must be set on a buffer before calling <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ext_tid</em>&nbsp;</td><td>template ID of the new external template within the current domain. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="aff8d9e237f95baf75040575af0df2962"></a><!-- doxytag: member="public.h::fBufSetExportTime" ref="aff8d9e237f95baf75040575af0df2962" args="(fBuf_t *fbuf, uint32_t extime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fBufSetExportTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>extime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the export time on the message currently in a buffer. </p>
<p>This will be used as the export time of the message created by the first call to <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a> after the current message, if any, is emitted. Use 0 for the export time to cause the export time to be taken from the system clock at message creation time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>extime</em>&nbsp;</td><td>the export time in epoch seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28c6c56234351a793fd513b212bd31b8"></a><!-- doxytag: member="public.h::fBufSetInternalTemplate" ref="a28c6c56234351a793fd513b212bd31b8" args="(fBuf_t *fbuf, uint16_t int_tid, GError **err)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gboolean fBufSetInternalTemplate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="public_8h.html#ab1479ebe89aecd202bb628c33102129b">fBuf_t</a> *&nbsp;</td>
          <td class="paramname"> <em>fbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>int_tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GError **&nbsp;</td>
          <td class="paramname"> <em>err</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the internal template on a buffer to the given template ID. </p>
<p>The internal template describes the format of the record pointed to by the recbase parameter to <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a> (for export) and <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a> (for collection). The given template ID must identify a current internal template in the buffer's associated session.</p>
<p>An internal template must be set on a buffer before calling <a class="el" href="public_8h.html#ad3fdaa8626ff753c5b617707698c22b6" title="Append a record to a buffer.">fBufAppend()</a> or <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieve a record from a buffer.">fBufNext()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fbuf</em>&nbsp;</td><td>an IPFIX message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>int_tid</em>&nbsp;</td><td>template ID of the new internal template </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>An error description, set on failure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
</div>
      </div><!-- l-content -->
      <div id="l-footer">&copy; 2006-2013 Carnegie Mellon University</div>
    </div><!-- p-body -->
</body>
</html>   
